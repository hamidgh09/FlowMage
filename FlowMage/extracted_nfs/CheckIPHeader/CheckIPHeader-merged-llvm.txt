/***  checkipheader.hh ***/

#ifndef CLICK_CHECKIPHEADER_HH
#define CLICK_CHECKIPHEADER_HH
#include <click/batchelement.hh>
#include <click/atomic.hh>
CLICK_DECLS
class Args;

/*
=c

CheckIPHeader([OFFSET, I<keywords> OFFSET, INTERFACES, BADSRC,
                       GOODDST, CHECKSUM, VERBOSE, DETAILS])

=s ip

checks IP header

=d

Input packets should have IP headers starting OFFSET bytes in. Default OFFSET
is zero. Checks that the packet's length is reasonable, and that the IP
version, header length, length, and checksum fields are valid. Checks that the
IP source address is a legal unicast address, or that the packet is destined
for one of this machine's addresses (see below). Shortens packets to the IP
length, if the IP length is shorter than the nominal packet length (due to
Ethernet padding, for example). Also sets the destination IP address
annotation to the actual destination IP address.

CheckIPHeader emits valid packets on output 0. Invalid packets are pushed out
on output 1, unless output 1 was unused; if so, drops invalid packets.

CheckIPHeader checks packets' source addresses for validity if one or more of
the INTERFACES, BADSRC, and GOODDST keyword arguments are supplied (RFC1812
5.3.7).

CheckIPHeader prints a message to the console the first time it encounters an
incorrect IP packet (but see VERBOSE below).

Keyword arguments are:

=over 5

=item CHECKSUM

Boolean. If true, then check each packet's checksum for validity; if false, do
not check the checksum. Default is true.

=item OFFSET

Unsigned integer. Byte position at which the IP header begins. Default is 0.

=item BADSRC

Space-separated list of IP addresses. CheckIPHeader will drop packets whose
source address is on this list (but see GOODDST below). Default is empty.

=item GOODDST

Space-separated list of IP addresses. CheckIPHeader exempts packets whose
destination address is on this list from BADSRC processing. Default is empty.

=item INTERFACES

Space-separated list of IP addresses with network prefixes, meant to represent
this router's interface addresses. This argument specifies both BADSRC and
GOODDST. Specifically, the argument "INTERFACES 18.26.4.9/24 18.32.9.44/28"
acts like a BADSRC of "18.26.4.255 18.32.9.47 0.0.0.0 255.255.255.255" -- the
set of broadcast addresses for this router -- and a GOODDST of "18.26.4.9
18.32.9.44". Default is not given.

=item VERBOSE

Boolean. If it is true, then a message will be printed for every erroneous
packet, rather than just the first. False by default.

=item DETAILS

Boolean. If it is true, then CheckIPHeader will maintain detailed counts of
how many packets were dropped for each possible reason, accessible through the
C<drop_details> handler. False by default.

=back

=n

CheckIPHeader supports an old configuration syntax:

CheckIPHeader([BADSRC2, OFFSET, I<keywords>])

The BADSRC2 argument behaves like the BADSRC keyword, except that if you use
this syntax, 0.0.0.0 and 255.255.255.255 considered bad addresses in addition
to those explicitly in the list. This syntax is deprecated and should not be
used in new configurations.

=h count read-only

Returns the number of correct packets CheckIPHeader has seen.

=h drops read-only

Returns the number of incorrect packets CheckIPHeader has seen.

=h drop_details read-only

Returns a text file showing how many erroneous packets CheckIPHeader has seen,
subdivided by error. Only available if the DETAILS keyword argument is true.

=a CheckIPHeader2, MarkIPHeader, SetIPChecksum, StripIPHeader,
CheckTCPHeader, CheckUDPHeader, CheckICMPHeader
*/

class CheckIPHeader : public SimpleElement<CheckIPHeader> {
    public:
        CheckIPHeader() CLICK_COLD;
        ~CheckIPHeader() CLICK_COLD;

        const char *class_name() const override { return "CheckIPHeader"; }
        const char *port_count() const override { return PORTS_1_1X2; }
        const char *processing() const override { return PROCESSING_A_AH; }
        const char *flags() const      { return Element::AGNOSTIC; }

        int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
        void add_handlers() CLICK_COLD;

        Packet *simple_action(Packet *p);

        struct OldBadSrcArg {
            static bool parse(const String &str, Vector<IPAddress> &result, Args &args);
        };

        struct InterfacesArg {
            static bool parse(
                const String &str, Vector<IPAddress> &result_bad_src,
                Vector<IPAddress> &result_good_dst, Args &args
            );
        };
    protected:

        enum Reason {
            MINISCULE_PACKET = 0,
            BAD_VERSION,
            BAD_HLEN,
            BAD_IP_LEN,
            BAD_CHECKSUM,
            BAD_SADDR,
            NREASONS
        };
    private:
        unsigned _offset;
        Vector<IPAddress> _bad_src;   // array of illegal IP src addresses

        bool _checksum;
    #if HAVE_FAST_CHECKSUM && FAST_CHECKSUM_ALIGNED
        bool _aligned;
    #endif
        bool _verbose;

        Vector<IPAddress> _good_dst;  // array of IP dst addrs for which _bad_src does not apply

        atomic_uint64_t _count;
        atomic_uint64_t _drops;
        atomic_uint64_t *_reason_drops;

        static const char * const reason_texts[NREASONS];

        enum { h_count, h_drops, h_drop_details };

        inline Reason valid(Packet *p);
        Packet *drop(Reason reason, Packet *p, bool batch);
        static String read_handler(Element *e, void *thunk) CLICK_COLD;

        friend class CheckIPHeader2;
};

CLICK_ENDDECLS
#endif


/***  checkipheader.cc ***/

/*
 * checkipheader.{cc,hh} -- element checks IP header for correctness
 * (checksums, lengths, source addresses)
 * Robert Morris, Eddie Kohler
 *
 * Computational batching support and counter & handler updates
 * by Georgios Katsikas
 *
 * Copyright (c) 1999-2000 Massachusetts Institute of Technology
 * Copyright (c) 2003 International Computer Science Institute
 * Copyright (c) 2020 UBITECH and KTH Royal Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, subject to the conditions
 * listed in the Click LICENSE file. These conditions include: you must
 * preserve this copyright notice, and you cannot mention the copyright
 * holders in advertising related to the Software without their permission.
 * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
 * notice is a summary of the Click LICENSE file; the license in that file is
 * legally binding.
 */

#include <click/config.h>
#include "checkipheader.hh"
#include <clicknet/ip.h>
#include <click/glue.hh>
#include <click/args.hh>
#include <click/straccum.hh>
#include <click/error.hh>
#include <click/standard/alignmentinfo.hh>

CLICK_DECLS

const char * const CheckIPHeader::reason_texts[NREASONS] = {
    "tiny packet", "bad IPv4 version", "bad IPv4 header length",
    "bad IPv4 length", "bad IPv4 checksum", "bad source address"
};

#define IPADDR_LIST_INTERFACES ((void *)0)
#define IPADDR_LIST_BADSRC     ((void *)1)
#define IPADDR_LIST_BADSRC_OLD ((void *)2)

bool
CheckIPHeader::OldBadSrcArg::parse(const String &str, Vector<IPAddress> &result, Args &args)
{
    if (IPAddressArg().parse(str, result, args)) {
        result.push_back(IPAddress(0));
        result.push_back(IPAddress(0xFFFFFFFFU));
        return true;
    } else {
        return false;
    }
}

bool
CheckIPHeader::InterfacesArg::parse(const String &str, Vector<IPAddress> &result_bad_src,
    Vector<IPAddress> &result_good_dst, Args &args)
{
    String arg(str);
    IPAddress ip, mask;
    int nwords = 0;
    while (String word = cp_shift_spacevec(arg)) {
        ++nwords;
        if (IPPrefixArg(true).parse(word, ip, mask, args)) {
            result_bad_src.push_back((ip & mask) | ~mask);
            result_good_dst.push_back(ip);
        } else {
            return false;
        }
    }

    if (nwords == result_bad_src.size()) {
        result_bad_src.push_back(IPAddress(0));
        result_bad_src.push_back(IPAddress(0xFFFFFFFFU));
        return true;
    }

    args.error("out of memory");
    return false;
}

CheckIPHeader::CheckIPHeader() : _checksum(true), _reason_drops(0)
{
    _count = 0;
    _drops = 0;
}

CheckIPHeader::~CheckIPHeader()
{
    if (_reason_drops) {
        delete _reason_drops;
    }
}

int
CheckIPHeader::configure(Vector<String> &conf, ErrorHandler *errh)
{
    _offset = 0;
    bool verbose = false;
    bool details = false;

    if (Args(this, errh).bind(conf)
        .read("INTERFACES", InterfacesArg(), _bad_src, _good_dst)
        .read("BADSRC", _bad_src)
        .read("GOODDST", _good_dst)
        .read_or_set("OFFSET", _offset, 0)
        .read_or_set("VERBOSE", verbose, 0)
        .read("DETAILS", details)
        .read_or_set("CHECKSUM", _checksum, 0)
        .consume() < 0)
        return -1;

    if (Args(conf, this, errh)
        .read("BADSRC", OldBadSrcArg(), _bad_src)
        .read("OFFSET", _offset)
        .complete() < 0)
        return -1;

    _verbose = verbose;
    if (details) {
        _reason_drops = new atomic_uint64_t[NREASONS];
        memset(_reason_drops, 0, NREASONS * sizeof(atomic_uint64_t));
    }

#if HAVE_FAST_CHECKSUM && FAST_CHECKSUM_ALIGNED
    // check alignment
    if (_checksum) {
        int ans, c, o;
        ans = AlignmentInfo::query(this, 0, c, o);
        o = (o + 4 - (_offset % 4)) % 4;
        _aligned = (ans && c == 4 && o == 0);
        if (!_aligned)
            errh->warning("IP header unaligned, cannot use fast IP checksum");
        if (!ans)
            errh->message("(Try passing the configuration through `click-align'.)");
    }
#endif

    return 0;
}

Packet *
CheckIPHeader::drop(Reason reason, Packet *p, bool batch)
{
    if (_drops == 0 || _verbose) {
        click_chatter("%s: IP header check failed: %s", name().c_str(), reason_texts[reason]);
    }
    _drops++;

    if (_reason_drops) {
        _reason_drops[reason]++;
    }

    if (noutputs() == 2) {
        output(1).push(p);
    } else {
        p->kill();
    }

    return 0;
}

inline CheckIPHeader::Reason CheckIPHeader::valid(Packet* p) {
    unsigned plen = p->length() - _offset;

    // cast to int so very large plen is interpreted as negative
    if ((int)plen < (int)sizeof(click_ip))
        return MINISCULE_PACKET;

    const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + _offset);
    if (ip->ip_v != 4)
        return BAD_VERSION;

    unsigned hlen = ip->ip_hl << 2;
    if (hlen < sizeof(click_ip))
        return BAD_HLEN;

    unsigned len = ntohs(ip->ip_len);
    if (len > plen || len < hlen)
        return BAD_IP_LEN;

    if (_checksum) {
        int val;
    #if HAVE_FAST_CHECKSUM && FAST_CHECKSUM_ALIGNED
        if (_aligned)
            val = ip_fast_csum((unsigned char *)ip, ip->ip_hl);
        else
            val = click_in_cksum((const unsigned char *)ip, hlen);
    #elif HAVE_FAST_CHECKSUM
        val = ip_fast_csum((unsigned char *)ip, ip->ip_hl);
    #else
        val = click_in_cksum((const unsigned char *)ip, hlen);
    #endif
        if (val != 0)
            return BAD_CHECKSUM;
    }

    /*
    * RFC1812 5.3.7 and 4.2.2.11: discard illegal source addresses.
    * Configuration string should have listed all subnet
    * broadcast addresses known to this router.
    */
    if (find(_bad_src.begin(), _bad_src.end(), IPAddress(ip->ip_src)) < _bad_src.end() &&
        find(_good_dst.begin(), _good_dst.end(), IPAddress(ip->ip_dst)) == _good_dst.end())
        return BAD_SADDR;

    /*
    * RFC1812 4.2.3.1: discard illegal destinations.
    * We now do this in the IP routing table.
    */
    p->set_ip_header(ip, hlen);

    // shorten packet according to IP length field -- 7/28/2000
    if (plen > len)
        p->take(plen - len);

    // set destination IP address annotation if it doesn't exist already --
    // 9/26/2001
    // always set destination IP address annotation; linuxmodule problem
    // reported by Parveen Kumar Patel at Utah -- 4/3/2002
    p->set_dst_ip_anno(ip->ip_dst);

    _count++;

    return NREASONS;
}

Packet *
CheckIPHeader::simple_action(Packet *p)
{
    Reason r;
    if ((r = valid(p)) == NREASONS) {
        return p;
    } else {
        drop(r, p, false);
        return NULL;
    }
}

String
CheckIPHeader::read_handler(Element *e, void *thunk)
{
    CheckIPHeader *c = reinterpret_cast<CheckIPHeader *>(e);

    switch (reinterpret_cast<uintptr_t>(thunk)) {
        case h_count: {
            return String(c->_count);
        }
        case h_drops: {
            return String(c->_drops);
        }
        case h_drop_details: {
            StringAccum sa;
            for (unsigned i = 0; i < NREASONS; i++) {
                sa.snprintf(15, "%15" PRIu64, c->_reason_drops[i].value());
                sa << " packets due to: ";
                sa.snprintf(24, "%24s", reason_texts[i]);
                sa << "\n";
            }
            return sa.take_string();
        }
        default: {
            return String();
        }
    }
}

void
CheckIPHeader::add_handlers()
{
    add_read_handler("count", read_handler, h_count);
    add_read_handler("drops", read_handler, h_drops);
    if (_reason_drops)
        add_read_handler("drop_details", read_handler, h_drop_details);
}

CLICK_ENDDECLS
EXPORT_ELEMENT(CheckIPHeader)
ELEMENT_MT_SAFE(CheckIPHeader)


/***  CheckIPHeader_llvm.txt ***/

define dso_local void @_ZN14CheckIPHeader2C2Ev(%class.CheckIPHeader2* %0) unnamed_addr #2 align 2 personality i32 (...)* @__gxx_personality_v0 {
  %2 = getelementptr %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0
  %3 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 1
  %4 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 2
  store i8 0, i8* %4, align 4, !tbaa !20277
  %5 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 0
  %6 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %5, i64 0, i32 0
  store %class.Element* null, %class.Element** %6, align 8, !tbaa !20278
  %7 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 0, i32 1
  store i32 -2, i32* %7, align 8, !tbaa !20280
  %8 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 1, i32 0
  store %class.Element* null, %class.Element** %8, align 8, !tbaa !20278
  %9 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 1, i32 1
  store i32 -2, i32* %9, align 8, !tbaa !20280
  %10 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 2, i32 0
  store %class.Element* null, %class.Element** %10, align 8, !tbaa !20278
  %11 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 2, i32 1
  store i32 -2, i32* %11, align 8, !tbaa !20280
  %12 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 3, i32 0
  store %class.Element* null, %class.Element** %12, align 8, !tbaa !20278
  %13 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 5, i64 3, i32 1
  store i32 -2, i32* %13, align 8, !tbaa !20280
  %14 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 7
  store %class.Router* null, %class.Router** %14, align 8, !tbaa !20281
  %15 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 8
  store i32 -1, i32* %15, align 8, !tbaa !20282
  %16 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 10
  %17 = bitcast %class.Vector* %16 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(17) %17, i8 0, i64 17, i1 false) #34
  %18 = load i32, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %19 = add nsw i32 %18, 1
  store i32 %19, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %20 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 4, i64 1
  store %"class.Element::Port"* %5, %"class.Element::Port"** %20, align 8, !tbaa !20284
  %21 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 4, i64 0
  store %"class.Element::Port"* %5, %"class.Element::Port"** %21, align 8, !tbaa !20284
  %22 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 6, i64 1
  store i32 0, i32* %22, align 4, !tbaa !20283
  %23 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 0, i32 0, i32 0, i32 6, i64 0
  store i32 0, i32* %23, align 8, !tbaa !20283
  store i32 1, i32* %3, align 8, !tbaa !20267
  %24 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 2
  %25 = bitcast %class.Vector.2* %24 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %25, i8 0, i64 16, i1 false) #34
  %26 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 3
  %27 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 5
  %28 = bitcast %class.Vector.2* %27 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %28, i8 0, i64 16, i1 false) #34
  %29 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 9
  store %class.atomic_uint64_t* null, %class.atomic_uint64_t** %29, align 16, !tbaa !23484
  %30 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 7, i32 0
  store volatile i64 0, i64* %30, align 16, !tbaa !20964
  %31 = getelementptr inbounds %class.CheckIPHeader2, %class.CheckIPHeader2* %0, i64 0, i32 0, i32 8, i32 0
  store volatile i64 0, i64* %31, align 16, !tbaa !20964
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [39 x i8*] }, { [39 x i8*] }* @_ZTV14CheckIPHeader2, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 16, !tbaa !20285
  store i8 0, i8* %26, align 16, !tbaa !23486
  ret void
}

define dso_local void @_ZN14CheckIPHeader2D2Ev(%class.CheckIPHeader2* %0) unnamed_addr #2 align 2 {
  %2 = bitcast %class.CheckIPHeader2* %0 to %class.CheckIPHeader*
  tail call void @_ZN13CheckIPHeaderD2Ev(%class.CheckIPHeader* %2) #34
  ret void
}

define dso_local void @_ZN14CheckIPHeader2D0Ev(%class.CheckIPHeader2* %0) unnamed_addr #2 align 2 {
  %2 = bitcast %class.CheckIPHeader2* %0 to %class.CheckIPHeader*
  tail call void @_ZN13CheckIPHeaderD2Ev(%class.CheckIPHeader* %2) #34
  ret void
}

define internal void @_ZN13SimpleElementI13CheckIPHeaderE4pushEiP6Packet(%class.SimpleElement* %0, i32 %1, %class.Packet* %2) unnamed_addr #0 comdat align 2 {
  %4 = bitcast %class.SimpleElement* %0 to %class.CheckIPHeader*
  %5 = bitcast %class.SimpleElement* %0 to %class.Packet* (%class.CheckIPHeader*, %class.Packet*)***
  %6 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)**, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*** %5, align 8, !tbaa !20285
  %7 = getelementptr inbounds %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %6, i64 4
  %8 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %7, align 8
  %9 = tail call %class.Packet* %8(%class.CheckIPHeader* %4, %class.Packet* %2)
  %10 = icmp eq %class.Packet* %9, null
  br i1 %10, label %31, label %11

11:                                               ; preds = %3
  %12 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 6, i64 1
  %13 = load i32, i32* %12, align 4, !tbaa !20283
  %14 = icmp ugt i32 %13, %1
  br i1 %14, label %16, label %15

15:                                               ; preds = %11
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

16:                                               ; preds = %11
  %17 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 4, i64 1
  %18 = load %"class.Element::Port"*, %"class.Element::Port"** %17, align 8, !tbaa !20284
  %19 = sext i32 %1 to i64
  %20 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %18, i64 %19, i32 0
  %21 = load %class.Element*, %class.Element** %20, align 8, !tbaa !20278
  %22 = icmp eq %class.Element* %21, null
  br i1 %22, label %23, label %24

23:                                               ; preds = %16
  tail call void @__assert_fail(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.58.14334, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 767, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4Port4pushEP6Packet.14335, i64 0, i64 0)) #57
  unreachable

24:                                               ; preds = %16
  %25 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %18, i64 %19, i32 1
  %26 = load i32, i32* %25, align 8, !tbaa !20280
  %27 = bitcast %class.Element* %21 to void (%class.Element*, i32, %class.Packet*)***
  %28 = load void (%class.Element*, i32, %class.Packet*)**, void (%class.Element*, i32, %class.Packet*)*** %27, align 8, !tbaa !20285
  %29 = getelementptr inbounds void (%class.Element*, i32, %class.Packet*)*, void (%class.Element*, i32, %class.Packet*)** %28, i64 2
  %30 = load void (%class.Element*, i32, %class.Packet*)*, void (%class.Element*, i32, %class.Packet*)** %29, align 8
  tail call void %30(%class.Element* nonnull %21, i32 %26, %class.Packet* nonnull %9)
  br label %31

31:                                               ; preds = %24, %3
  ret void
}

define internal %class.Packet* @_ZN13SimpleElementI13CheckIPHeaderE4pullEi(%class.SimpleElement* %0, i32 %1) unnamed_addr #0 comdat align 2 {
  %3 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 6, i64 0
  %4 = load i32, i32* %3, align 4, !tbaa !20283
  %5 = icmp ugt i32 %4, %1
  br i1 %5, label %7, label %6

6:                                                ; preds = %2
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

7:                                                ; preds = %2
  %8 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 4, i64 0
  %9 = load %"class.Element::Port"*, %"class.Element::Port"** %8, align 8, !tbaa !20284
  %10 = sext i32 %1 to i64
  %11 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %9, i64 %10, i32 0
  %12 = load %class.Element*, %class.Element** %11, align 8, !tbaa !20278
  %13 = icmp eq %class.Element* %12, null
  br i1 %13, label %14, label %15

14:                                               ; preds = %7
  tail call void @__assert_fail(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.59.14332, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 843, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4Port4pullEv.14333, i64 0, i64 0)) #57
  unreachable

15:                                               ; preds = %7
  %16 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %9, i64 %10, i32 1
  %17 = load i32, i32* %16, align 8, !tbaa !20280
  %18 = bitcast %class.Element* %12 to %class.Packet* (%class.Element*, i32)***
  %19 = load %class.Packet* (%class.Element*, i32)**, %class.Packet* (%class.Element*, i32)*** %18, align 8, !tbaa !20285
  %20 = getelementptr inbounds %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %19, i64 3
  %21 = load %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %20, align 8
  %22 = tail call %class.Packet* %21(%class.Element* nonnull %12, i32 %17)
  %23 = icmp eq %class.Packet* %22, null
  br i1 %23, label %31, label %24

24:                                               ; preds = %15
  %25 = bitcast %class.SimpleElement* %0 to %class.CheckIPHeader*
  %26 = bitcast %class.SimpleElement* %0 to %class.Packet* (%class.CheckIPHeader*, %class.Packet*)***
  %27 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)**, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*** %26, align 8, !tbaa !20285
  %28 = getelementptr inbounds %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %27, i64 4
  %29 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %28, align 8
  %30 = tail call %class.Packet* %29(%class.CheckIPHeader* %25, %class.Packet* nonnull %22)
  br label %31

31:                                               ; preds = %24, %15
  %32 = phi %class.Packet* [ %30, %24 ], [ null, %15 ]
  ret %class.Packet* %32
}

define internal void @_ZN13SimpleElementI13CheckIPHeaderE10push_batchEiP11PacketBatch(%class.SimpleElement* %0, i32 %1, %class.PacketBatch* %2) unnamed_addr #0 comdat align 2 {
  %4 = icmp eq %class.PacketBatch* %2, null
  br i1 %4, label %5, label %9

5:                                                ; preds = %3
  %6 = load i16, i16* inttoptr (i64 72 to i16*), align 8, !tbaa !20287
  %7 = icmp eq i16 %6, 0
  br i1 %7, label %8, label %87

8:                                                ; preds = %5
  tail call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.259.16395, i64 0, i64 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6.13925, i64 0, i64 0), i32 439, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__PRETTY_FUNCTION__._ZN11PacketBatch5countEv.13926, i64 0, i64 0)) #57
  unreachable

9:                                                ; preds = %3
  %10 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %2, i64 48, i32 0
  %11 = getelementptr inbounds i8, i8* %10, i64 24
  %12 = bitcast i8* %11 to i16*
  %13 = load i16, i16* %12, align 2, !tbaa !20287
  %14 = icmp eq i16 %13, 0
  br i1 %14, label %15, label %16

15:                                               ; preds = %9
  tail call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.259.16395, i64 0, i64 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6.13925, i64 0, i64 0), i32 439, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__PRETTY_FUNCTION__._ZN11PacketBatch5countEv.13926, i64 0, i64 0)) #57
  unreachable

16:                                               ; preds = %9
  %17 = zext i16 %13 to i32
  %18 = bitcast %class.PacketBatch* %2 to %class.Packet*
  %19 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %2, i64 136
  %20 = bitcast %class.PacketBatch* %19 to %class.Packet**
  %21 = bitcast %class.SimpleElement* %0 to %class.CheckIPHeader*
  %22 = bitcast %class.SimpleElement* %0 to %class.Packet* (%class.CheckIPHeader*, %class.Packet*)***
  br label %23

23:                                               ; preds = %55, %16
  %24 = phi %class.PacketBatch* [ %2, %16 ], [ %58, %55 ]
  %25 = phi i32 [ %17, %16 ], [ %57, %55 ]
  %26 = phi %class.Packet* [ null, %16 ], [ %56, %55 ]
  %27 = phi %class.Packet* [ %18, %16 ], [ %29, %55 ]
  %28 = phi %class.Packet** [ %20, %16 ], [ %60, %55 ]
  %29 = load %class.Packet*, %class.Packet** %28, align 8, !tbaa !20284
  %30 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)**, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*** %22, align 8, !tbaa !20285
  %31 = getelementptr inbounds %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %30, i64 4
  %32 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %31, align 8
  %33 = tail call %class.Packet* %32(%class.CheckIPHeader* %21, %class.Packet* nonnull %27)
  %34 = icmp eq %class.Packet* %33, null
  br i1 %34, label %35, label %44

35:                                               ; preds = %23
  %36 = icmp eq %class.Packet* %26, null
  br i1 %36, label %39, label %37

37:                                               ; preds = %35
  %38 = getelementptr inbounds %class.Packet, %class.Packet* %26, i64 0, i32 6, i32 6
  store %class.Packet* %29, %class.Packet** %38, align 8, !tbaa !20337
  br label %41

39:                                               ; preds = %35
  %40 = bitcast %class.Packet* %29 to %class.PacketBatch*
  br label %41

41:                                               ; preds = %39, %37
  %42 = phi %class.PacketBatch* [ %24, %37 ], [ %40, %39 ]
  %43 = add nsw i32 %25, -1
  br label %55

44:                                               ; preds = %23
  %45 = icmp eq %class.Packet* %33, %27
  br i1 %45, label %55, label %46

46:                                               ; preds = %44
  %47 = icmp eq %class.Packet* %26, null
  br i1 %47, label %50, label %48

48:                                               ; preds = %46
  %49 = getelementptr inbounds %class.Packet, %class.Packet* %26, i64 0, i32 6, i32 6
  store %class.Packet* %33, %class.Packet** %49, align 8, !tbaa !20337
  br label %52

50:                                               ; preds = %46
  %51 = bitcast %class.Packet* %33 to %class.PacketBatch*
  br label %52

52:                                               ; preds = %50, %48
  %53 = phi %class.PacketBatch* [ %24, %48 ], [ %51, %50 ]
  %54 = getelementptr inbounds %class.Packet, %class.Packet* %33, i64 0, i32 6, i32 6
  store %class.Packet* %29, %class.Packet** %54, align 8, !tbaa !20337
  br label %55

55:                                               ; preds = %52, %44, %41
  %56 = phi %class.Packet* [ %26, %41 ], [ %27, %44 ], [ %33, %52 ]
  %57 = phi i32 [ %43, %41 ], [ %25, %44 ], [ %25, %52 ]
  %58 = phi %class.PacketBatch* [ %42, %41 ], [ %24, %44 ], [ %53, %52 ]
  %59 = icmp eq %class.Packet* %29, null
  %60 = getelementptr inbounds %class.Packet, %class.Packet* %29, i64 0, i32 6, i32 6
  br i1 %59, label %61, label %23

61:                                               ; preds = %55
  %62 = icmp eq %class.PacketBatch* %58, null
  br i1 %62, label %87, label %63

63:                                               ; preds = %61
  %64 = trunc i32 %57 to i16
  %65 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %58, i64 48, i32 0
  %66 = getelementptr inbounds i8, i8* %65, i64 24
  %67 = bitcast i8* %66 to i16*
  store i16 %64, i16* %67, align 2, !tbaa !20287
  %68 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %58, i64 144
  %69 = bitcast %class.PacketBatch* %68 to %class.Packet**
  store %class.Packet* %56, %class.Packet** %69, align 8, !tbaa !20334
  %70 = getelementptr inbounds %class.Packet, %class.Packet* %56, i64 0, i32 6, i32 6
  store %class.Packet* null, %class.Packet** %70, align 8, !tbaa !20337
  %71 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 6, i64 1
  %72 = load i32, i32* %71, align 4, !tbaa !20283
  %73 = icmp ugt i32 %72, %1
  br i1 %73, label %75, label %74

74:                                               ; preds = %63
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

75:                                               ; preds = %63
  %76 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 4, i64 1
  %77 = load %"class.Element::Port"*, %"class.Element::Port"** %76, align 8, !tbaa !20284
  %78 = sext i32 %1 to i64
  %79 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %77, i64 %78, i32 0
  %80 = load %class.Element*, %class.Element** %79, align 8, !tbaa !20278
  %81 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %77, i64 %78, i32 1
  %82 = load i32, i32* %81, align 8, !tbaa !20280
  %83 = bitcast %class.Element* %80 to void (%class.Element*, i32, %class.PacketBatch*)***
  %84 = load void (%class.Element*, i32, %class.PacketBatch*)**, void (%class.Element*, i32, %class.PacketBatch*)*** %83, align 8, !tbaa !20285
  %85 = getelementptr inbounds void (%class.Element*, i32, %class.PacketBatch*)*, void (%class.Element*, i32, %class.PacketBatch*)** %84, i64 5
  %86 = load void (%class.Element*, i32, %class.PacketBatch*)*, void (%class.Element*, i32, %class.PacketBatch*)** %85, align 8
  tail call void %86(%class.Element* %80, i32 %82, %class.PacketBatch* nonnull %58)
  br label %87

87:                                               ; preds = %75, %61, %5
  ret void
}

define internal %class.PacketBatch* @_ZN13SimpleElementI13CheckIPHeaderE10pull_batchEij(%class.SimpleElement* %0, i32 %1, i32 %2) unnamed_addr #0 comdat align 2 {
  %4 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 6, i64 0
  %5 = load i32, i32* %4, align 4, !tbaa !20283
  %6 = icmp ugt i32 %5, %1
  br i1 %6, label %8, label %7

7:                                                ; preds = %3
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

8:                                                ; preds = %3
  %9 = getelementptr inbounds %class.SimpleElement, %class.SimpleElement* %0, i64 0, i32 0, i32 0, i32 4, i64 0
  %10 = load %"class.Element::Port"*, %"class.Element::Port"** %9, align 8, !tbaa !20284
  %11 = sext i32 %1 to i64
  %12 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %10, i64 %11, i32 0
  %13 = load %class.Element*, %class.Element** %12, align 8, !tbaa !20278
  %14 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %10, i64 %11, i32 1
  %15 = load i32, i32* %14, align 8, !tbaa !20280
  %16 = bitcast %class.Element* %13 to %class.PacketBatch* (%class.Element*, i32, i32)***
  %17 = load %class.PacketBatch* (%class.Element*, i32, i32)**, %class.PacketBatch* (%class.Element*, i32, i32)*** %16, align 8, !tbaa !20285
  %18 = getelementptr inbounds %class.PacketBatch* (%class.Element*, i32, i32)*, %class.PacketBatch* (%class.Element*, i32, i32)** %17, i64 6
  %19 = load %class.PacketBatch* (%class.Element*, i32, i32)*, %class.PacketBatch* (%class.Element*, i32, i32)** %18, align 8
  %20 = tail call %class.PacketBatch* %19(%class.Element* %13, i32 %15, i32 %2)
  %21 = icmp eq %class.PacketBatch* %20, null
  br i1 %21, label %84, label %22

22:                                               ; preds = %8
  %23 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %20, i64 48, i32 0
  %24 = getelementptr inbounds i8, i8* %23, i64 24
  %25 = bitcast i8* %24 to i16*
  %26 = load i16, i16* %25, align 2, !tbaa !20287
  %27 = icmp eq i16 %26, 0
  br i1 %27, label %28, label %29

28:                                               ; preds = %22
  tail call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.259.16395, i64 0, i64 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6.13925, i64 0, i64 0), i32 439, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__PRETTY_FUNCTION__._ZN11PacketBatch5countEv.13926, i64 0, i64 0)) #57
  unreachable

29:                                               ; preds = %22
  %30 = zext i16 %26 to i32
  %31 = bitcast %class.PacketBatch* %20 to %class.Packet*
  %32 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %20, i64 136
  %33 = bitcast %class.PacketBatch* %32 to %class.Packet**
  %34 = bitcast %class.SimpleElement* %0 to %class.CheckIPHeader*
  %35 = bitcast %class.SimpleElement* %0 to %class.Packet* (%class.CheckIPHeader*, %class.Packet*)***
  br label %36

36:                                               ; preds = %68, %29
  %37 = phi %class.PacketBatch* [ %20, %29 ], [ %71, %68 ]
  %38 = phi i32 [ %30, %29 ], [ %70, %68 ]
  %39 = phi %class.Packet* [ null, %29 ], [ %69, %68 ]
  %40 = phi %class.Packet* [ %31, %29 ], [ %42, %68 ]
  %41 = phi %class.Packet** [ %33, %29 ], [ %73, %68 ]
  %42 = load %class.Packet*, %class.Packet** %41, align 8, !tbaa !20284
  %43 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)**, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*** %35, align 8, !tbaa !20285
  %44 = getelementptr inbounds %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %43, i64 4
  %45 = load %class.Packet* (%class.CheckIPHeader*, %class.Packet*)*, %class.Packet* (%class.CheckIPHeader*, %class.Packet*)** %44, align 8
  %46 = tail call %class.Packet* %45(%class.CheckIPHeader* %34, %class.Packet* nonnull %40)
  %47 = icmp eq %class.Packet* %46, null
  br i1 %47, label %48, label %57

48:                                               ; preds = %36
  %49 = icmp eq %class.Packet* %39, null
  br i1 %49, label %52, label %50

50:                                               ; preds = %48
  %51 = getelementptr inbounds %class.Packet, %class.Packet* %39, i64 0, i32 6, i32 6
  store %class.Packet* %42, %class.Packet** %51, align 8, !tbaa !20337
  br label %54

52:                                               ; preds = %48
  %53 = bitcast %class.Packet* %42 to %class.PacketBatch*
  br label %54

54:                                               ; preds = %52, %50
  %55 = phi %class.PacketBatch* [ %37, %50 ], [ %53, %52 ]
  %56 = add nsw i32 %38, -1
  br label %68

57:                                               ; preds = %36
  %58 = icmp eq %class.Packet* %46, %40
  br i1 %58, label %68, label %59

59:                                               ; preds = %57
  %60 = icmp eq %class.Packet* %39, null
  br i1 %60, label %63, label %61

61:                                               ; preds = %59
  %62 = getelementptr inbounds %class.Packet, %class.Packet* %39, i64 0, i32 6, i32 6
  store %class.Packet* %46, %class.Packet** %62, align 8, !tbaa !20337
  br label %65

63:                                               ; preds = %59
  %64 = bitcast %class.Packet* %46 to %class.PacketBatch*
  br label %65

65:                                               ; preds = %63, %61
  %66 = phi %class.PacketBatch* [ %37, %61 ], [ %64, %63 ]
  %67 = getelementptr inbounds %class.Packet, %class.Packet* %46, i64 0, i32 6, i32 6
  store %class.Packet* %42, %class.Packet** %67, align 8, !tbaa !20337
  br label %68

68:                                               ; preds = %65, %57, %54
  %69 = phi %class.Packet* [ %39, %54 ], [ %40, %57 ], [ %46, %65 ]
  %70 = phi i32 [ %56, %54 ], [ %38, %57 ], [ %38, %65 ]
  %71 = phi %class.PacketBatch* [ %55, %54 ], [ %37, %57 ], [ %66, %65 ]
  %72 = icmp eq %class.Packet* %42, null
  %73 = getelementptr inbounds %class.Packet, %class.Packet* %42, i64 0, i32 6, i32 6
  br i1 %72, label %74, label %36

74:                                               ; preds = %68
  %75 = icmp eq %class.PacketBatch* %71, null
  br i1 %75, label %84, label %76

76:                                               ; preds = %74
  %77 = trunc i32 %70 to i16
  %78 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %71, i64 48, i32 0
  %79 = getelementptr inbounds i8, i8* %78, i64 24
  %80 = bitcast i8* %79 to i16*
  store i16 %77, i16* %80, align 2, !tbaa !20287
  %81 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %71, i64 144
  %82 = bitcast %class.PacketBatch* %81 to %class.Packet**
  store %class.Packet* %69, %class.Packet** %82, align 8, !tbaa !20334
  %83 = getelementptr inbounds %class.Packet, %class.Packet* %69, i64 0, i32 6, i32 6
  store %class.Packet* null, %class.Packet** %83, align 8, !tbaa !20337
  br label %84

84:                                               ; preds = %76, %74, %8
  %85 = phi %class.PacketBatch* [ null, %8 ], [ null, %74 ], [ %71, %76 ]
  ret %class.PacketBatch* %85
}

define internal i8* @_ZNK14CheckIPHeader210class_nameEv(%class.CheckIPHeader2* nocapture readnone %0) unnamed_addr #4 comdat align 2 {
  ret i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.122.13126, i64 0, i64 0)
}

define internal i8* @_ZNK13CheckIPHeader10port_countEv(%class.CheckIPHeader* nocapture readnone %0) unnamed_addr #4 comdat align 2 {
  ret i8* getelementptr inbounds ([6 x i8], [6 x i8]* @_ZN7Element11PORTS_1_1X2E, i64 0, i64 0)
}

define internal i8* @_ZNK13CheckIPHeader10processingEv(%class.CheckIPHeader* nocapture readnone %0) unnamed_addr #4 comdat align 2 {
  ret i8* getelementptr inbounds ([5 x i8], [5 x i8]* @_ZN7Element15PROCESSING_A_AHE, i64 0, i64 0)
}

define internal i8* @_ZNK13CheckIPHeader5flagsEv(%class.CheckIPHeader* nocapture readnone %0) unnamed_addr #4 comdat align 2 {
  ret i8* getelementptr inbounds ([2 x i8], [2 x i8]* @_ZN7Element8AGNOSTICE, i64 0, i64 0)
}

define dso_local zeroext i1 @_ZN13CheckIPHeader12OldBadSrcArg5parseERK6StringR6VectorI9IPAddressLm16EER4Args(%class.String* nocapture readonly dereferenceable(24) %0, %class.Vector.2* dereferenceable(16) %1, %class.Args* nocapture dereferenceable(112) %2) local_unnamed_addr #0 align 2 {
  %4 = alloca %class.atomic_uint32_t, align 4
  %5 = alloca %class.atomic_uint32_t, align 4
  %6 = bitcast %class.Args* %2 to %class.ArgContext*
  %7 = tail call zeroext i1 @_ZN12IPAddressArg5parseERK6StringR6VectorI9IPAddressLm16EERK10ArgContext(%class.String* nonnull dereferenceable(24) %0, %class.Vector.2* nonnull dereferenceable(16) %1, %class.ArgContext* nonnull dereferenceable(32) %6)
  br i1 %7, label %8, label %48

8:                                                ; preds = %3
  %9 = bitcast %class.atomic_uint32_t* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %9)
  %10 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %4, i64 0, i32 0
  store i32 0, i32* %10, align 4
  %11 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0, i32 1
  %12 = load i32, i32* %11, align 8, !tbaa !20475
  %13 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0, i32 2
  %14 = load i32, i32* %13, align 4, !tbaa !20474
  %15 = icmp slt i32 %12, %14
  br i1 %15, label %16, label %24

16:                                               ; preds = %8
  %17 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0, i32 0
  %18 = load %struct.char_array.4*, %struct.char_array.4** %17, align 8, !tbaa !20299
  %19 = sext i32 %12 to i64
  %20 = getelementptr inbounds %struct.char_array.4, %struct.char_array.4* %18, i64 %19, i32 0, i64 0
  %21 = bitcast i8* %20 to i32*
  store i32 0, i32* %21, align 1
  %22 = load i32, i32* %11, align 8, !tbaa !20475
  %23 = add nsw i32 %22, 1
  store i32 %23, i32* %11, align 8, !tbaa !20475
  br label %29

24:                                               ; preds = %8
  %25 = bitcast %class.atomic_uint32_t* %4 to %struct.char_array.4*
  %26 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0
  %27 = call zeroext i1 @_ZN13vector_memoryI18sized_array_memoryILm4EELm16EE21reserve_and_push_backEiPK10char_arrayILm4EE(%class.vector_memory.3* nonnull %26, i32 -1, %struct.char_array.4* nonnull %25)
  %28 = load i32, i32* %11, align 8, !tbaa !20475
  br label %29

29:                                               ; preds = %24, %16
  %30 = phi i32 [ %23, %16 ], [ %28, %24 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %9)
  %31 = bitcast %class.atomic_uint32_t* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %31)
  %32 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %5, i64 0, i32 0
  store i32 -1, i32* %32, align 4
  %33 = load i32, i32* %13, align 4, !tbaa !20474
  %34 = icmp slt i32 %30, %33
  br i1 %34, label %35, label %43

35:                                               ; preds = %29
  %36 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0, i32 0
  %37 = load %struct.char_array.4*, %struct.char_array.4** %36, align 8, !tbaa !20299
  %38 = sext i32 %30 to i64
  %39 = getelementptr inbounds %struct.char_array.4, %struct.char_array.4* %37, i64 %38, i32 0, i64 0
  %40 = bitcast i8* %39 to i32*
  store i32 -1, i32* %40, align 1
  %41 = load i32, i32* %11, align 8, !tbaa !20475
  %42 = add nsw i32 %41, 1
  store i32 %42, i32* %11, align 8, !tbaa !20475
  br label %47

43:                                               ; preds = %29
  %44 = bitcast %class.atomic_uint32_t* %5 to %struct.char_array.4*
  %45 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0
  %46 = call zeroext i1 @_ZN13vector_memoryI18sized_array_memoryILm4EELm16EE21reserve_and_push_backEiPK10char_arrayILm4EE(%class.vector_memory.3* nonnull %45, i32 -1, %struct.char_array.4* nonnull %44)
  br label %47

47:                                               ; preds = %43, %35
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %31)
  br label %48

48:                                               ; preds = %47, %3
  %49 = phi i1 [ true, %47 ], [ false, %3 ]
  ret i1 %49
}

define dso_local zeroext i1 @_ZN13CheckIPHeader13InterfacesArg5parseERK6StringR6VectorI9IPAddressLm16EES7_R4Args(%class.String* nocapture readonly dereferenceable(24) %0, %class.Vector.2* dereferenceable(16) %1, %class.Vector.2* dereferenceable(16) %2, %class.Args* nocapture dereferenceable(112) %3) local_unnamed_addr #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  %5 = alloca %class.atomic_uint32_t, align 4
  %6 = alloca %class.atomic_uint32_t, align 4
  %7 = alloca i8, align 1
  %8 = alloca i8, align 1
  %9 = alloca %class.atomic_uint32_t, align 4
  %10 = alloca %class.atomic_uint32_t, align 4
  %11 = alloca i8, align 1
  %12 = alloca i8, align 1
  %13 = alloca %class.String, align 8
  %14 = alloca %class.atomic_uint32_t, align 4
  %15 = alloca %class.atomic_uint32_t, align 4
  %16 = alloca %class.String, align 8
  %17 = alloca %class.PacketBatch, align 1
  %18 = bitcast %class.String* %13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %18) #34
  %19 = bitcast %class.String* %0 to i64*
  %20 = load i64, i64* %19, align 8, !tbaa !20330
  %21 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 1
  %22 = load i32, i32* %21, align 8, !tbaa !20308
  %23 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 2
  %24 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %23, align 8, !tbaa !20316
  %25 = bitcast %class.String* %13 to i64*
  store i64 %20, i64* %25, align 8, !tbaa !20330
  %26 = getelementptr inbounds %class.String, %class.String* %13, i64 0, i32 0, i32 1
  store i32 %22, i32* %26, align 8, !tbaa !20308
  %27 = getelementptr inbounds %class.String, %class.String* %13, i64 0, i32 0, i32 2
  store %"struct.String::memo_t"* %24, %"struct.String::memo_t"** %27, align 8, !tbaa !20316
  %28 = icmp eq %"struct.String::memo_t"* %24, null
  br i1 %28, label %31, label %29

29:                                               ; preds = %4
  %30 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %24, i64 0, i32 0
  tail call void asm sideeffect "lock ; incl $0", "=*m,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %30, i32* nonnull %30) #34, !srcloc !23487
  br label %31

31:                                               ; preds = %29, %4
  %32 = bitcast %class.atomic_uint32_t* %14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %32) #34
  %33 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %14, i64 0, i32 0
  store i32 0, i32* %33, align 4, !tbaa !21122
  %34 = bitcast %class.atomic_uint32_t* %15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %34) #34
  %35 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %15, i64 0, i32 0
  store i32 0, i32* %35, align 4, !tbaa !21122
  %36 = bitcast %class.String* %16 to i8*
  %37 = getelementptr inbounds %class.String, %class.String* %16, i64 0, i32 0, i32 1
  %38 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %17, i64 0, i32 0
  %39 = bitcast %class.Args* %3 to %class.ArgContext*
  %40 = bitcast %class.atomic_uint32_t* %10 to i8*
  %41 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %10, i64 0, i32 0
  %42 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0, i32 1
  %43 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0, i32 2
  %44 = bitcast %class.atomic_uint32_t* %10 to %struct.char_array.4*
  %45 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0
  %46 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %1, i64 0, i32 0, i32 0
  %47 = bitcast %class.atomic_uint32_t* %9 to i8*
  %48 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %9, i64 0, i32 0
  %49 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %2, i64 0, i32 0, i32 1
  %50 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %2, i64 0, i32 0, i32 2
  %51 = bitcast %class.atomic_uint32_t* %9 to %struct.char_array.4*
  %52 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %2, i64 0, i32 0
  %53 = getelementptr inbounds %class.Vector.2, %class.Vector.2* %2, i64 0, i32 0, i32 0
  %54 = getelementptr inbounds %class.String, %class.String* %16, i64 0, i32 0, i32 2
  br label %55

55:                                               ; preds = %137, %31
  %56 = phi i32 [ 0, %31 ], [ %108, %137 ]
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %36) #34
  call void @_Z17cp_shift_spacevecR6String(%class.String* nonnull sret %16, %class.String* nonnull dereferenceable(24) %13)
  %57 = load i32, i32* %37, align 8, !tbaa !20308
  %58 = icmp eq i32 %57, 0
  %59 = select i1 %58, { i64, i64 } zeroinitializer, { i64, i64 } { i64 ptrtoint (i32 (%class.String*)* @_ZNK6String6lengthEv to i64), i64 0 }
  %60 = extractvalue { i64, i64 } %59, 0
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %106, label %66

62:                                               ; preds = %99, %85
  %63 = landingpad { i8*, i32 }
          cleanup
  %64 = extractvalue { i8*, i32 } %63, 0
  %65 = extractvalue { i8*, i32 } %63, 1
  br label %138

66:                                               ; preds = %55
  %67 = add nsw i32 %56, 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %38) #34
  store i8 1, i8* %38, align 1, !tbaa !22127
  %68 = invoke zeroext i1 @_ZNK11IPPrefixArg5parseERK6StringR9IPAddressS4_RK10ArgContext(%class.PacketBatch* nonnull %17, %class.String* nonnull dereferenceable(24) %16, %class.atomic_uint32_t* nonnull dereferenceable(4) %14, %class.atomic_uint32_t* nonnull dereferenceable(4) %15, %class.ArgContext* nonnull dereferenceable(32) %39)
          to label %69 unwind label %102

69:                                               ; preds = %66
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %38) #34
  br i1 %68, label %70, label %106

70:                                               ; preds = %69
  %71 = load i32, i32* %33, align 4, !tbaa.struct !20922
  %72 = load i32, i32* %35, align 4, !tbaa.struct !20922
  %73 = xor i32 %72, -1
  %74 = or i32 %71, %73
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %40)
  store i32 %74, i32* %41, align 4
  %75 = load i32, i32* %42, align 8, !tbaa !20475
  %76 = load i32, i32* %43, align 4, !tbaa !20474
  %77 = icmp slt i32 %75, %76
  br i1 %77, label %78, label %85

78:                                               ; preds = %70
  %79 = load %struct.char_array.4*, %struct.char_array.4** %46, align 8, !tbaa !20299
  %80 = sext i32 %75 to i64
  %81 = getelementptr inbounds %struct.char_array.4, %struct.char_array.4* %79, i64 %80, i32 0, i64 0
  %82 = bitcast i8* %81 to i32*
  store i32 %74, i32* %82, align 1
  %83 = load i32, i32* %42, align 8, !tbaa !20475
  %84 = add nsw i32 %83, 1
  store i32 %84, i32* %42, align 8, !tbaa !20475
  br label %87

85:                                               ; preds = %70
  %86 = invoke zeroext i1 @_ZN13vector_memoryI18sized_array_memoryILm4EELm16EE21reserve_and_push_backEiPK10char_arrayILm4EE(%class.vector_memory.3* nonnull %45, i32 -1, %struct.char_array.4* nonnull %44)
          to label %87 unwind label %62

87:                                               ; preds = %85, %78
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %40)
  %88 = load i32, i32* %33, align 4, !tbaa.struct !20922
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %47)
  store i32 %88, i32* %48, align 4
  %89 = load i32, i32* %49, align 8, !tbaa !20475
  %90 = load i32, i32* %50, align 4, !tbaa !20474
  %91 = icmp slt i32 %89, %90
  br i1 %91, label %92, label %99

92:                                               ; preds = %87
  %93 = load %struct.char_array.4*, %struct.char_array.4** %53, align 8, !tbaa !20299
  %94 = sext i32 %89 to i64
  %95 = getelementptr inbounds %struct.char_array.4, %struct.char_array.4* %93, i64 %94, i32 0, i64 0
  %96 = bitcast i8* %95 to i32*
  store i32 %88, i32* %96, align 1
  %97 = load i32, i32* %49, align 8, !tbaa !20475
  %98 = add nsw i32 %97, 1
  store i32 %98, i32* %49, align 8, !tbaa !20475
  br label %101

99:                                               ; preds = %87
  %100 = invoke zeroext i1 @_ZN13vector_memoryI18sized_array_memoryILm4EELm16EE21reserve_and_push_backEiPK10char_arrayILm4EE(%class.vector_memory.3* nonnull %52, i32 -1, %struct.char_array.4* nonnull %51)
          to label %101 unwind label %62

101:                                              ; preds = %99, %92
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %47)
  br label %106

102:                                              ; preds = %66
  %103 = landingpad { i8*, i32 }
          cleanup
  %104 = extractvalue { i8*, i32 } %103, 0
  %105 = extractvalue { i8*, i32 } %103, 1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %38) #34
  br label %138

106:                                              ; preds = %101, %69, %55
  %107 = phi i32 [ 3, %55 ], [ 1, %69 ], [ 0, %101 ]
  %108 = phi i32 [ %56, %55 ], [ %67, %69 ], [ %67, %101 ]
  %109 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %54, align 8, !tbaa !20316
  %110 = icmp eq %"struct.String::memo_t"* %109, null
  br i1 %110, label %137, label %111

111:                                              ; preds = %106
  %112 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %109, i64 0, i32 0
  %113 = load volatile i32, i32* %112, align 4, !tbaa !20317
  %114 = icmp eq i32 %113, 0
  br i1 %114, label %115, label %116

115:                                              ; preds = %111
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4.16721, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.16722, i64 0, i64 0), i32 289, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__PRETTY_FUNCTION__._ZNK6String5derefEv.16723, i64 0, i64 0)) #57
  unreachable

116:                                              ; preds = %111
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %8) #34
  call void asm sideeffect "lock ; decl $0 ; sete $1", "=*m,=*qm,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %112, i8* nonnull %8, i32* nonnull %112) #34, !srcloc !23488
  %117 = load i8, i8* %8, align 1, !tbaa !20287
  %118 = icmp eq i8 %117, 0
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %8) #34
  br i1 %118, label %136, label %119

119:                                              ; preds = %116
  %120 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %54, align 8, !tbaa !20316
  %121 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %120, i64 0, i32 0
  %122 = load volatile i32, i32* %121, align 4, !tbaa !20317
  %123 = icmp eq i32 %122, 0
  br i1 %123, label %125, label %124

124:                                              ; preds = %119
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.13507, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 133, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

125:                                              ; preds = %119
  %126 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %120, i64 0, i32 1
  %127 = load i32, i32* %126, align 4, !tbaa !20320
  %128 = icmp eq i32 %127, 0
  br i1 %128, label %129, label %130

129:                                              ; preds = %125
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.13508, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 134, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

130:                                              ; preds = %125
  %131 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %120, i64 0, i32 2
  %132 = load volatile i32, i32* %131, align 4, !tbaa !20321
  %133 = icmp ult i32 %127, %132
  br i1 %133, label %134, label %_ZN6String11delete_memoEPNS_6memo_tE.exit

134:                                              ; preds = %130
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.13509, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 135, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

_ZN6String11delete_memoEPNS_6memo_tE.exit:        ; preds = %130
  %135 = bitcast %"struct.String::memo_t"* %120 to i8*
  call void @_ZdaPv(i8* %135) #55
  br label %136

136:                                              ; preds = %_ZN6String11delete_memoEPNS_6memo_tE.exit, %116
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %54, align 8, !tbaa !20316
  br label %137

137:                                              ; preds = %136, %106
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %36) #34
  switch i32 %107, label %.loopexit [
    i32 0, label %55
    i32 3, label %170
  ]

138:                                              ; preds = %102, %62
  %139 = phi i32 [ %65, %62 ], [ %105, %102 ]
  %140 = phi i8* [ %64, %62 ], [ %104, %102 ]
  %141 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %54, align 8, !tbaa !20316
  %142 = icmp eq %"struct.String::memo_t"* %141, null
  br i1 %142, label %169, label %143

143:                                              ; preds = %138
  %144 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %141, i64 0, i32 0
  %145 = load volatile i32, i32* %144, align 4, !tbaa !20317
  %146 = icmp eq i32 %145, 0
  br i1 %146, label %147, label %148

147:                                              ; preds = %143
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4.16721, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.16722, i64 0, i64 0), i32 289, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__PRETTY_FUNCTION__._ZNK6String5derefEv.16723, i64 0, i64 0)) #57
  unreachable

148:                                              ; preds = %143
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %7) #34
  call void asm sideeffect "lock ; decl $0 ; sete $1", "=*m,=*qm,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %144, i8* nonnull %7, i32* nonnull %144) #34, !srcloc !23488
  %149 = load i8, i8* %7, align 1, !tbaa !20287
  %150 = icmp eq i8 %149, 0
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %7) #34
  br i1 %150, label %168, label %151

151:                                              ; preds = %148
  %152 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %54, align 8, !tbaa !20316
  %153 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %152, i64 0, i32 0
  %154 = load volatile i32, i32* %153, align 4, !tbaa !20317
  %155 = icmp eq i32 %154, 0
  br i1 %155, label %157, label %156

156:                                              ; preds = %151
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.13507, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 133, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

157:                                              ; preds = %151
  %158 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %152, i64 0, i32 1
  %159 = load i32, i32* %158, align 4, !tbaa !20320
  %160 = icmp eq i32 %159, 0
  br i1 %160, label %161, label %162

161:                                              ; preds = %157
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.13508, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 134, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

162:                                              ; preds = %157
  %163 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %152, i64 0, i32 2
  %164 = load volatile i32, i32* %163, align 4, !tbaa !20321
  %165 = icmp ult i32 %159, %164
  br i1 %165, label %166, label %_ZN6String11delete_memoEPNS_6memo_tE.exit9

166:                                              ; preds = %162
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.13509, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 135, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

_ZN6String11delete_memoEPNS_6memo_tE.exit9:       ; preds = %162
  %167 = bitcast %"struct.String::memo_t"* %152 to i8*
  call void @_ZdaPv(i8* %167) #55
  br label %168

168:                                              ; preds = %_ZN6String11delete_memoEPNS_6memo_tE.exit9, %148
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %54, align 8, !tbaa !20316
  br label %169

169:                                              ; preds = %168, %138
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %36) #34
  br label %240

170:                                              ; preds = %137
  %171 = load i32, i32* %42, align 8, !tbaa !22573
  %172 = icmp eq i32 %108, %171
  br i1 %172, label %173, label %211

173:                                              ; preds = %170
  %174 = bitcast %class.atomic_uint32_t* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %174)
  %175 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %6, i64 0, i32 0
  store i32 0, i32* %175, align 4
  %176 = load i32, i32* %43, align 4, !tbaa !20474
  %177 = icmp slt i32 %108, %176
  br i1 %177, label %178, label %185

178:                                              ; preds = %173
  %179 = load %struct.char_array.4*, %struct.char_array.4** %46, align 8, !tbaa !20299
  %180 = sext i32 %108 to i64
  %181 = getelementptr inbounds %struct.char_array.4, %struct.char_array.4* %179, i64 %180, i32 0, i64 0
  %182 = bitcast i8* %181 to i32*
  store i32 0, i32* %182, align 1
  %183 = load i32, i32* %42, align 8, !tbaa !20475
  %184 = add nsw i32 %183, 1
  store i32 %184, i32* %42, align 8, !tbaa !20475
  br label %190

185:                                              ; preds = %173
  %186 = bitcast %class.atomic_uint32_t* %6 to %struct.char_array.4*
  %187 = invoke zeroext i1 @_ZN13vector_memoryI18sized_array_memoryILm4EELm16EE21reserve_and_push_backEiPK10char_arrayILm4EE(%class.vector_memory.3* nonnull %45, i32 -1, %struct.char_array.4* nonnull %186)
          to label %188 unwind label %207

188:                                              ; preds = %185
  %189 = load i32, i32* %42, align 8, !tbaa !20475
  br label %190

190:                                              ; preds = %188, %178
  %191 = phi i32 [ %189, %188 ], [ %184, %178 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %174)
  %192 = bitcast %class.atomic_uint32_t* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %192)
  %193 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %5, i64 0, i32 0
  store i32 -1, i32* %193, align 4
  %194 = load i32, i32* %43, align 4, !tbaa !20474
  %195 = icmp slt i32 %191, %194
  br i1 %195, label %196, label %203

196:                                              ; preds = %190
  %197 = load %struct.char_array.4*, %struct.char_array.4** %46, align 8, !tbaa !20299
  %198 = sext i32 %191 to i64
  %199 = getelementptr inbounds %struct.char_array.4, %struct.char_array.4* %197, i64 %198, i32 0, i64 0
  %200 = bitcast i8* %199 to i32*
  store i32 -1, i32* %200, align 1
  %201 = load i32, i32* %42, align 8, !tbaa !20475
  %202 = add nsw i32 %201, 1
  store i32 %202, i32* %42, align 8, !tbaa !20475
  br label %206

203:                                              ; preds = %190
  %204 = bitcast %class.atomic_uint32_t* %5 to %struct.char_array.4*
  %205 = invoke zeroext i1 @_ZN13vector_memoryI18sized_array_memoryILm4EELm16EE21reserve_and_push_backEiPK10char_arrayILm4EE(%class.vector_memory.3* nonnull %45, i32 -1, %struct.char_array.4* nonnull %204)
          to label %206 unwind label %207

206:                                              ; preds = %203, %196
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %192)
  br label %.loopexit

207:                                              ; preds = %211, %203, %185
  %208 = landingpad { i8*, i32 }
          cleanup
  %209 = extractvalue { i8*, i32 } %208, 0
  %210 = extractvalue { i8*, i32 } %208, 1
  br label %240

211:                                              ; preds = %170
  invoke void (%class.ArgContext*, i8*, ...) @_ZNK10ArgContext5errorEPKcz(%class.ArgContext* nonnull %39, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.17.15777, i64 0, i64 0))
          to label %.loopexit unwind label %207

.loopexit:                                        ; preds = %211, %206, %137
  %212 = phi i1 [ true, %206 ], [ false, %211 ], [ false, %137 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %34) #34
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %32) #34
  %213 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %27, align 8, !tbaa !20316
  %214 = icmp eq %"struct.String::memo_t"* %213, null
  br i1 %214, label %239, label %215

215:                                              ; preds = %.loopexit
  %216 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %213, i64 0, i32 0
  %217 = load volatile i32, i32* %216, align 4, !tbaa !20317
  %218 = icmp eq i32 %217, 0
  br i1 %218, label %219, label %220

219:                                              ; preds = %215
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4.16721, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.16722, i64 0, i64 0), i32 289, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__PRETTY_FUNCTION__._ZNK6String5derefEv.16723, i64 0, i64 0)) #57
  unreachable

220:                                              ; preds = %215
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %11) #34
  call void asm sideeffect "lock ; decl $0 ; sete $1", "=*m,=*qm,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %216, i8* nonnull %11, i32* nonnull %216) #34, !srcloc !23488
  %221 = load i8, i8* %11, align 1, !tbaa !20287
  %222 = icmp eq i8 %221, 0
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %11) #34
  br i1 %222, label %238, label %223

223:                                              ; preds = %220
  %224 = load volatile i32, i32* %216, align 4, !tbaa !20317
  %225 = icmp eq i32 %224, 0
  br i1 %225, label %227, label %226

226:                                              ; preds = %223
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.13507, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 133, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

227:                                              ; preds = %223
  %228 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %213, i64 0, i32 1
  %229 = load i32, i32* %228, align 4, !tbaa !20320
  %230 = icmp eq i32 %229, 0
  br i1 %230, label %231, label %232

231:                                              ; preds = %227
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.13508, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 134, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

232:                                              ; preds = %227
  %233 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %213, i64 0, i32 2
  %234 = load volatile i32, i32* %233, align 4, !tbaa !20321
  %235 = icmp ult i32 %229, %234
  br i1 %235, label %236, label %_ZN6String11delete_memoEPNS_6memo_tE.exit10

236:                                              ; preds = %232
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.13509, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 135, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

_ZN6String11delete_memoEPNS_6memo_tE.exit10:      ; preds = %232
  %237 = bitcast %"struct.String::memo_t"* %213 to i8*
  call void @_ZdaPv(i8* %237) #55
  br label %238

238:                                              ; preds = %_ZN6String11delete_memoEPNS_6memo_tE.exit10, %220
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %27, align 8, !tbaa !20316
  br label %239

239:                                              ; preds = %238, %.loopexit
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %18) #34
  ret i1 %212

240:                                              ; preds = %207, %169
  %241 = phi i32 [ %210, %207 ], [ %139, %169 ]
  %242 = phi i8* [ %209, %207 ], [ %140, %169 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %34) #34
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %32) #34
  %243 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %27, align 8, !tbaa !20316
  %244 = icmp eq %"struct.String::memo_t"* %243, null
  br i1 %244, label %269, label %245

245:                                              ; preds = %240
  %246 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %243, i64 0, i32 0
  %247 = load volatile i32, i32* %246, align 4, !tbaa !20317
  %248 = icmp eq i32 %247, 0
  br i1 %248, label %249, label %250

249:                                              ; preds = %245
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4.16721, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.16722, i64 0, i64 0), i32 289, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__PRETTY_FUNCTION__._ZNK6String5derefEv.16723, i64 0, i64 0)) #57
  unreachable

250:                                              ; preds = %245
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %12) #34
  call void asm sideeffect "lock ; decl $0 ; sete $1", "=*m,=*qm,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %246, i8* nonnull %12, i32* nonnull %246) #34, !srcloc !23488
  %251 = load i8, i8* %12, align 1, !tbaa !20287
  %252 = icmp eq i8 %251, 0
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %12) #34
  br i1 %252, label %268, label %253

253:                                              ; preds = %250
  %254 = load volatile i32, i32* %246, align 4, !tbaa !20317
  %255 = icmp eq i32 %254, 0
  br i1 %255, label %257, label %256

256:                                              ; preds = %253
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.13507, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 133, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

257:                                              ; preds = %253
  %258 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %243, i64 0, i32 1
  %259 = load i32, i32* %258, align 4, !tbaa !20320
  %260 = icmp eq i32 %259, 0
  br i1 %260, label %261, label %262

261:                                              ; preds = %257
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.13508, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 134, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

262:                                              ; preds = %257
  %263 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %243, i64 0, i32 2
  %264 = load volatile i32, i32* %263, align 4, !tbaa !20321
  %265 = icmp ult i32 %259, %264
  br i1 %265, label %266, label %_ZN6String11delete_memoEPNS_6memo_tE.exit11

266:                                              ; preds = %262
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.13509, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 135, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

_ZN6String11delete_memoEPNS_6memo_tE.exit11:      ; preds = %262
  %267 = bitcast %"struct.String::memo_t"* %243 to i8*
  call void @_ZdaPv(i8* %267) #55
  br label %268

268:                                              ; preds = %_ZN6String11delete_memoEPNS_6memo_tE.exit11, %250
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %27, align 8, !tbaa !20316
  br label %269

269:                                              ; preds = %268, %240
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %18) #34
  %270 = insertvalue { i8*, i32 } undef, i8* %242, 0
  %271 = insertvalue { i8*, i32 } %270, i32 %241, 1
  resume { i8*, i32 } %271
}

define dso_local void @_ZN13CheckIPHeaderC2Ev(%class.CheckIPHeader* %0) unnamed_addr #2 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  %2 = getelementptr %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 0
  %3 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 1
  %4 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 2
  store i8 0, i8* %4, align 4, !tbaa !20277
  %5 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 0
  %6 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %5, i64 0, i32 0
  store %class.Element* null, %class.Element** %6, align 8, !tbaa !20278
  %7 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 0, i32 1
  store i32 -2, i32* %7, align 8, !tbaa !20280
  %8 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 1, i32 0
  store %class.Element* null, %class.Element** %8, align 8, !tbaa !20278
  %9 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 1, i32 1
  store i32 -2, i32* %9, align 8, !tbaa !20280
  %10 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 2, i32 0
  store %class.Element* null, %class.Element** %10, align 8, !tbaa !20278
  %11 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 2, i32 1
  store i32 -2, i32* %11, align 8, !tbaa !20280
  %12 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 3, i32 0
  store %class.Element* null, %class.Element** %12, align 8, !tbaa !20278
  %13 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 3, i32 1
  store i32 -2, i32* %13, align 8, !tbaa !20280
  %14 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 7
  store %class.Router* null, %class.Router** %14, align 8, !tbaa !20281
  %15 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 8
  store i32 -1, i32* %15, align 8, !tbaa !20282
  %16 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 10
  %17 = bitcast %class.Vector* %16 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(17) %17, i8 0, i64 17, i1 false) #34
  %18 = load i32, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %19 = add nsw i32 %18, 1
  store i32 %19, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %20 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 4, i64 1
  store %"class.Element::Port"* %5, %"class.Element::Port"** %20, align 8, !tbaa !20284
  %21 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 4, i64 0
  store %"class.Element::Port"* %5, %"class.Element::Port"** %21, align 8, !tbaa !20284
  %22 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 6, i64 1
  store i32 0, i32* %22, align 4, !tbaa !20283
  %23 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 6, i64 0
  store i32 0, i32* %23, align 8, !tbaa !20283
  store i32 1, i32* %3, align 8, !tbaa !20267
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [39 x i8*] }, { [39 x i8*] }* @_ZTV13CheckIPHeader, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 16, !tbaa !20285
  %24 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 2
  %25 = bitcast %class.Vector.2* %24 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %25, i8 0, i64 16, i1 false) #34
  %26 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 3
  store i8 1, i8* %26, align 16, !tbaa !23486
  %27 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 5
  %28 = bitcast %class.Vector.2* %27 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %28, i8 0, i64 16, i1 false) #34
  %29 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 9
  store %class.atomic_uint64_t* null, %class.atomic_uint64_t** %29, align 16, !tbaa !23484
  %30 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 7, i32 0
  store volatile i64 0, i64* %30, align 16, !tbaa !20964
  %31 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 8, i32 0
  store volatile i64 0, i64* %31, align 16, !tbaa !20964
  ret void
}

define dso_local void @_ZN13CheckIPHeaderD2Ev(%class.CheckIPHeader* %0) unnamed_addr #2 align 2 personality i32 (...)* @__gxx_personality_v0 {
  %2 = getelementptr %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 0
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [39 x i8*] }, { [39 x i8*] }* @_ZTV13CheckIPHeader, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 16, !tbaa !20285
  %3 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 9
  %4 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %3, align 16, !tbaa !23484
  %5 = icmp eq %class.atomic_uint64_t* %4, null
  br i1 %5, label %8, label %6

6:                                                ; preds = %1
  %7 = bitcast %class.atomic_uint64_t* %4 to i8*
  tail call void @_ZdlPv(i8* %7) #55
  br label %8

8:                                                ; preds = %6, %1
  %9 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 5
  %10 = bitcast %class.Vector.2* %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !20299
  %12 = icmp eq i8* %11, null
  br i1 %12, label %14, label %13

13:                                               ; preds = %8
  tail call void @_ZdaPv(i8* nonnull %11) #55
  br label %14

14:                                               ; preds = %13, %8
  %15 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 2
  %16 = bitcast %class.Vector.2* %15 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !20299
  %18 = icmp eq i8* %17, null
  br i1 %18, label %20, label %19

19:                                               ; preds = %14
  tail call void @_ZdaPv(i8* nonnull %17) #55
  br label %20

20:                                               ; preds = %19, %14
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [38 x i8*] }, { [38 x i8*] }* @_ZTV7Element, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8, !tbaa !20285
  %21 = load i32, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %22 = add nsw i32 %21, -1
  store i32 %22, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %23 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 4, i64 0
  %24 = load %"class.Element::Port"*, %"class.Element::Port"** %23, align 8, !tbaa !20284
  %25 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 0
  %26 = icmp uge %"class.Element::Port"* %24, %25
  %27 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 6
  %28 = bitcast [2 x i32]* %27 to %"class.Element::Port"*
  %29 = icmp ule %"class.Element::Port"* %24, %28
  %30 = and i1 %29, %26
  %31 = icmp eq %"class.Element::Port"* %24, null
  %32 = or i1 %31, %30
  br i1 %32, label %35, label %33

33:                                               ; preds = %20
  %34 = bitcast %"class.Element::Port"* %24 to i8*
  tail call void @_ZdaPv(i8* %34) #55
  br label %35

35:                                               ; preds = %33, %20
  %36 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 4, i64 1
  %37 = load %"class.Element::Port"*, %"class.Element::Port"** %36, align 8, !tbaa !20284
  %38 = icmp uge %"class.Element::Port"* %37, %25
  %39 = icmp ule %"class.Element::Port"* %37, %28
  %40 = and i1 %39, %38
  %41 = icmp eq %"class.Element::Port"* %37, null
  %42 = or i1 %41, %40
  br i1 %42, label %45, label %43

43:                                               ; preds = %35
  %44 = bitcast %"class.Element::Port"* %37 to i8*
  tail call void @_ZdaPv(i8* %44) #55
  br label %45

45:                                               ; preds = %43, %35
  %46 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 10
  %47 = bitcast %class.Vector* %46 to i8**
  %48 = load i8*, i8** %47, align 8, !tbaa !20288
  %49 = icmp eq i8* %48, null
  br i1 %49, label %_ZN12BatchElementD2Ev.exit, label %50

50:                                               ; preds = %45
  tail call void @_ZdaPv(i8* nonnull %48) #55
  br label %_ZN12BatchElementD2Ev.exit

_ZN12BatchElementD2Ev.exit:                       ; preds = %50, %45
  ret void
}

define dso_local void @_ZN13CheckIPHeaderD0Ev(%class.CheckIPHeader* %0) unnamed_addr #2 align 2 personality i32 (...)* @__gxx_personality_v0 {
  %2 = getelementptr %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 0
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [39 x i8*] }, { [39 x i8*] }* @_ZTV13CheckIPHeader, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 16, !tbaa !20285
  %3 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 9
  %4 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %3, align 16, !tbaa !23484
  %5 = icmp eq %class.atomic_uint64_t* %4, null
  br i1 %5, label %8, label %6

6:                                                ; preds = %1
  %7 = bitcast %class.atomic_uint64_t* %4 to i8*
  tail call void @_ZdlPv(i8* %7) #55
  br label %8

8:                                                ; preds = %6, %1
  %9 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 5
  %10 = bitcast %class.Vector.2* %9 to i8**
  %11 = load i8*, i8** %10, align 8, !tbaa !20299
  %12 = icmp eq i8* %11, null
  br i1 %12, label %14, label %13

13:                                               ; preds = %8
  tail call void @_ZdaPv(i8* nonnull %11) #55
  br label %14

14:                                               ; preds = %13, %8
  %15 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 2
  %16 = bitcast %class.Vector.2* %15 to i8**
  %17 = load i8*, i8** %16, align 8, !tbaa !20299
  %18 = icmp eq i8* %17, null
  br i1 %18, label %20, label %19

19:                                               ; preds = %14
  tail call void @_ZdaPv(i8* nonnull %17) #55
  br label %20

20:                                               ; preds = %19, %14
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [38 x i8*] }, { [38 x i8*] }* @_ZTV7Element, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8, !tbaa !20285
  %21 = load i32, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %22 = add nsw i32 %21, -1
  store i32 %22, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %23 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 4, i64 0
  %24 = load %"class.Element::Port"*, %"class.Element::Port"** %23, align 8, !tbaa !20284
  %25 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 5, i64 0
  %26 = icmp uge %"class.Element::Port"* %24, %25
  %27 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 6
  %28 = bitcast [2 x i32]* %27 to %"class.Element::Port"*
  %29 = icmp ule %"class.Element::Port"* %24, %28
  %30 = and i1 %29, %26
  %31 = icmp eq %"class.Element::Port"* %24, null
  %32 = or i1 %31, %30
  br i1 %32, label %35, label %33

33:                                               ; preds = %20
  %34 = bitcast %"class.Element::Port"* %24 to i8*
  tail call void @_ZdaPv(i8* %34) #55
  br label %35

35:                                               ; preds = %33, %20
  %36 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 4, i64 1
  %37 = load %"class.Element::Port"*, %"class.Element::Port"** %36, align 8, !tbaa !20284
  %38 = icmp uge %"class.Element::Port"* %37, %25
  %39 = icmp ule %"class.Element::Port"* %37, %28
  %40 = and i1 %39, %38
  %41 = icmp eq %"class.Element::Port"* %37, null
  %42 = or i1 %41, %40
  br i1 %42, label %45, label %43

43:                                               ; preds = %35
  %44 = bitcast %"class.Element::Port"* %37 to i8*
  tail call void @_ZdaPv(i8* %44) #55
  br label %45

45:                                               ; preds = %43, %35
  %46 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 10
  %47 = bitcast %class.Vector* %46 to i8**
  %48 = load i8*, i8** %47, align 8, !tbaa !20288
  %49 = icmp eq i8* %48, null
  br i1 %49, label %_ZN12BatchElementD2Ev.exit, label %50

50:                                               ; preds = %45
  tail call void @_ZdaPv(i8* nonnull %48) #55
  br label %_ZN12BatchElementD2Ev.exit

_ZN12BatchElementD2Ev.exit:                       ; preds = %50, %45
  ret void
}

define dso_local %class.Packet* @_ZN13CheckIPHeader13simple_actionEP6Packet(%class.CheckIPHeader* %0, %class.Packet* %1) unnamed_addr #0 align 2 {
  %3 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 4
  %4 = bitcast i8** %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !20396
  %6 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 3
  %7 = bitcast i8** %6 to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !20399
  %9 = sub i64 %5, %8
  %10 = trunc i64 %9 to i32
  %11 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 1
  %12 = load i32, i32* %11, align 4, !tbaa !23489
  %13 = sub i32 %10, %12
  %14 = icmp slt i32 %13, 20
  br i1 %14, label %121, label %15

15:                                               ; preds = %2
  %16 = inttoptr i64 %8 to i8*
  %17 = zext i32 %12 to i64
  %18 = getelementptr inbounds i8, i8* %16, i64 %17
  %19 = load i8, i8* %18, align 4
  %20 = and i8 %19, -16
  %21 = icmp eq i8 %20, 64
  br i1 %21, label %22, label %121

22:                                               ; preds = %15
  %23 = shl i8 %19, 2
  %24 = and i8 %23, 60
  %25 = zext i8 %24 to i32
  %26 = icmp ult i8 %24, 20
  br i1 %26, label %121, label %27

27:                                               ; preds = %22
  %28 = getelementptr inbounds i8, i8* %18, i64 2
  %29 = bitcast i8* %28 to i16*
  %30 = load i16, i16* %29, align 2, !tbaa !21050
  %31 = tail call i16 @llvm.bswap.i16(i16 %30) #34
  %32 = zext i16 %31 to i32
  %33 = icmp ult i32 %13, %32
  %34 = icmp ult i32 %32, %25
  %35 = or i1 %33, %34
  br i1 %35, label %121, label %36

36:                                               ; preds = %27
  %37 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 3
  %38 = load i8, i8* %37, align 16, !tbaa !23486, !range !20292
  %39 = icmp eq i8 %38, 0
  br i1 %39, label %43, label %40

40:                                               ; preds = %36
  %41 = tail call zeroext i16 @click_in_cksum(i8* nonnull %18, i32 %25)
  %42 = icmp eq i16 %41, 0
  br i1 %42, label %43, label %121

43:                                               ; preds = %40, %36
  %44 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 2
  %45 = bitcast %class.Vector.2* %44 to %class.atomic_uint32_t**
  %46 = load %class.atomic_uint32_t*, %class.atomic_uint32_t** %45, align 8, !tbaa !22643
  %47 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 2, i32 0, i32 1
  %48 = load i32, i32* %47, align 8, !tbaa !22573
  %49 = sext i32 %48 to i64
  %50 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %46, i64 %49
  %51 = getelementptr inbounds i8, i8* %18, i64 12
  %52 = bitcast i8* %51 to i32*
  %53 = load i32, i32* %52, align 4, !tbaa.struct !20922
  %54 = icmp sgt i32 %48, 0
  br i1 %54, label %.preheader2, label %.loopexit3

.preheader2:                                      ; preds = %59, %43
  %55 = phi %class.atomic_uint32_t* [ %60, %59 ], [ %46, %43 ]
  %56 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %55, i64 0, i32 0
  %57 = load i32, i32* %56, align 4, !tbaa.struct !20922
  %58 = icmp eq i32 %57, %53
  br i1 %58, label %.loopexit3, label %59

59:                                               ; preds = %.preheader2
  %60 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %55, i64 1
  %61 = icmp ult %class.atomic_uint32_t* %60, %50
  br i1 %61, label %.preheader2, label %.loopexit3

.loopexit3:                                       ; preds = %59, %.preheader2, %43
  %62 = phi %class.atomic_uint32_t* [ %46, %43 ], [ %55, %.preheader2 ], [ %60, %59 ]
  %63 = icmp ult %class.atomic_uint32_t* %62, %50
  br i1 %63, label %64, label %85

64:                                               ; preds = %.loopexit3
  %65 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 5
  %66 = bitcast %class.Vector.2* %65 to %class.atomic_uint32_t**
  %67 = load %class.atomic_uint32_t*, %class.atomic_uint32_t** %66, align 8, !tbaa !22643
  %68 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 5, i32 0, i32 1
  %69 = load i32, i32* %68, align 8, !tbaa !22573
  %70 = sext i32 %69 to i64
  %71 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %67, i64 %70
  %72 = getelementptr inbounds i8, i8* %18, i64 16
  %73 = bitcast i8* %72 to i32*
  %74 = load i32, i32* %73, align 4, !tbaa.struct !20922
  %75 = icmp sgt i32 %69, 0
  br i1 %75, label %.preheader, label %.loopexit

.preheader:                                       ; preds = %80, %64
  %76 = phi %class.atomic_uint32_t* [ %81, %80 ], [ %67, %64 ]
  %77 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %76, i64 0, i32 0
  %78 = load i32, i32* %77, align 4, !tbaa.struct !20922
  %79 = icmp eq i32 %78, %74
  br i1 %79, label %.loopexit, label %80

80:                                               ; preds = %.preheader
  %81 = getelementptr inbounds %class.atomic_uint32_t, %class.atomic_uint32_t* %76, i64 1
  %82 = icmp ult %class.atomic_uint32_t* %81, %71
  br i1 %82, label %.preheader, label %.loopexit

.loopexit:                                        ; preds = %80, %.preheader, %64
  %83 = phi %class.atomic_uint32_t* [ %67, %64 ], [ %76, %.preheader ], [ %81, %80 ]
  %84 = icmp eq %class.atomic_uint32_t* %83, %71
  br i1 %84, label %121, label %85

85:                                               ; preds = %.loopexit, %.loopexit3
  %86 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 2
  %87 = load i8*, i8** %86, align 8, !tbaa !21043
  %88 = icmp ugt i8* %87, %18
  br i1 %88, label %95, label %89

89:                                               ; preds = %85
  %90 = zext i8 %24 to i64
  %91 = getelementptr inbounds i8, i8* %18, i64 %90
  %92 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 5
  %93 = load i8*, i8** %92, align 8, !tbaa !21044
  %94 = icmp ugt i8* %91, %93
  br i1 %94, label %95, label %96

95:                                               ; preds = %89, %85
  tail call void @__assert_fail(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.4.14495, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.14496, i64 0, i64 0), i32 2414, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @__PRETTY_FUNCTION__._ZN6Packet18set_network_headerEPKhj.14497, i64 0, i64 0)) #57
  unreachable

96:                                               ; preds = %89
  %97 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 6, i32 2
  store i8* %18, i8** %97, align 8, !tbaa !20400
  %98 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 6, i32 3
  store i8* %91, i8** %98, align 8, !tbaa !20562
  %99 = icmp ugt i32 %13, %32
  br i1 %99, label %100, label %_ZN13CheckIPHeader5validEP6Packet.exit

100:                                              ; preds = %96
  %101 = sub i32 %13, %32
  %102 = icmp ugt i32 %101, %10
  br i1 %102, label %103, label %108

103:                                              ; preds = %100
  tail call void (i8*, ...) @click_chatter(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.59.12744, i64 0, i64 0), i32 %101, i32 %10)
  %104 = load i64, i64* %4, align 8, !tbaa !20396
  %105 = load i64, i64* %7, align 8, !tbaa !20399
  %106 = sub i64 %104, %105
  %107 = trunc i64 %106 to i32
  br label %108

108:                                              ; preds = %103, %100
  %109 = phi i64 [ %104, %103 ], [ %5, %100 ]
  %110 = phi i32 [ %107, %103 ], [ %101, %100 ]
  %111 = inttoptr i64 %109 to i8*
  %112 = zext i32 %110 to i64
  %113 = sub nsw i64 0, %112
  %114 = getelementptr inbounds i8, i8* %111, i64 %113
  store i8* %114, i8** %3, align 8, !tbaa !20396
  br label %_ZN13CheckIPHeader5validEP6Packet.exit

_ZN13CheckIPHeader5validEP6Packet.exit:           ; preds = %108, %96
  %115 = getelementptr inbounds i8, i8* %18, i64 16
  %116 = bitcast i8* %115 to i32*
  %117 = load i32, i32* %116, align 4, !tbaa.struct !20922
  %118 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 6, i32 0
  %119 = bitcast %"union.Packet::Anno"* %118 to i32*
  store i32 %117, i32* %119, align 8, !tbaa !20287
  %120 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 7, i32 0
  tail call void asm sideeffect "lock ; incq $0", "=*m,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i64* nonnull %120, i64* nonnull %120) #34, !srcloc !23490
  br label %123

121:                                              ; preds = %.loopexit, %40, %27, %22, %15, %2
  %.ph = phi i32 [ 5, %.loopexit ], [ 3, %27 ], [ 4, %40 ], [ 2, %22 ], [ 1, %15 ], [ 0, %2 ]
  %122 = tail call %class.Packet* @_ZN13CheckIPHeader4dropENS_6ReasonEP6Packetb(%class.CheckIPHeader* %0, i32 %.ph, %class.Packet* %1, i1 zeroext undef)
  br label %123

123:                                              ; preds = %121, %_ZN13CheckIPHeader5validEP6Packet.exit
  %124 = phi %class.Packet* [ null, %121 ], [ %1, %_ZN13CheckIPHeader5validEP6Packet.exit ]
  ret %class.Packet* %124
}

define internal i8* @_ZNK13CheckIPHeader10class_nameEv(%class.CheckIPHeader* nocapture readnone %0) unnamed_addr #4 comdat align 2 {
  ret i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.123.13127, i64 0, i64 0)
}

define dso_local i32 @_ZN13CheckIPHeader9configureER6VectorI6StringLm16EEP12ErrorHandler(%class.CheckIPHeader* %0, %class.Vector.0* dereferenceable(16) %1, %class.ErrorHandler* %2) unnamed_addr #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  %4 = alloca i8, align 1
  %5 = alloca i8, align 1
  %6 = alloca %class.Args, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca %class.Args, align 8
  %11 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 1
  store i32 0, i32* %11, align 4, !tbaa !23489
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %4) #34
  store i8 0, i8* %4, align 1, !tbaa !20338
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %5) #34
  store i8 0, i8* %5, align 1, !tbaa !20338
  %12 = bitcast %class.Args* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 112, i8* nonnull %12) #34
  %13 = bitcast %class.Args* %6 to %class.CheckIPHeader**
  store %class.CheckIPHeader* %0, %class.CheckIPHeader** %13, align 8, !tbaa !20294
  %14 = getelementptr inbounds %class.Args, %class.Args* %6, i64 0, i32 0, i32 1
  store %class.ErrorHandler* %2, %class.ErrorHandler** %14, align 8, !tbaa !20296
  %15 = getelementptr inbounds %class.Args, %class.Args* %6, i64 0, i32 0, i32 2
  store i8* null, i8** %15, align 8, !tbaa !20297
  %16 = getelementptr inbounds %class.Args, %class.Args* %6, i64 0, i32 0, i32 3
  store i8 0, i8* %16, align 8, !tbaa !20298
  %17 = getelementptr inbounds %class.Args, %class.Args* %6, i64 0, i32 4
  %18 = getelementptr inbounds %class.Args, %class.Args* %6, i64 0, i32 1
  store i8 0, i8* %18, align 1, !tbaa !22020
  %19 = getelementptr inbounds %class.Args, %class.Args* %6, i64 0, i32 2
  %20 = bitcast %class.Vector.0** %17 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(33) %20, i8 0, i64 33, i1 false) #34
  store i8 1, i8* %19, align 2, !tbaa !20301
  %21 = getelementptr inbounds %class.Args, %class.Args* %6, i64 0, i32 3
  store i8 0, i8* %21, align 1, !tbaa !20305
  %22 = invoke dereferenceable(112) %class.Args* @_ZN4Args4bindER6VectorI6StringLm16EE(%class.Args* nonnull %6, %class.Vector.0* nonnull dereferenceable(16) %1)
          to label %23 unwind label %93

23:                                               ; preds = %3
  %24 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 2
  %25 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 5
  invoke fastcc void @_Z14args_base_readIN13CheckIPHeader13InterfacesArgE6VectorI9IPAddressLm16EES4_EvP4ArgsPKciT_RT0_RT1_(%class.Args* nonnull %22, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.2.4209, i64 0, i64 0), %class.Vector.2* nonnull dereferenceable(16) %24, %class.Vector.2* nonnull dereferenceable(16) %25)
          to label %26 unwind label %93

26:                                               ; preds = %23
  invoke fastcc void @_Z14args_base_readI6VectorI9IPAddressLm16EEEvP4ArgsPKciRT_(%class.Args* nonnull %22, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3.4210, i64 0, i64 0), i32 0, %class.Vector.2* nonnull dereferenceable(16) %24)
          to label %27 unwind label %93

27:                                               ; preds = %26
  invoke fastcc void @_Z14args_base_readI6VectorI9IPAddressLm16EEEvP4ArgsPKciRT_(%class.Args* nonnull %22, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.4.4211, i64 0, i64 0), i32 0, %class.Vector.2* nonnull dereferenceable(16) %25)
          to label %28 unwind label %93

28:                                               ; preds = %27
  %29 = bitcast i32* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %29) #34
  store i32 0, i32* %7, align 4, !tbaa !20283
  invoke fastcc void @_Z21args_base_read_or_setIjiEvP4ArgsPKciRT_RKT0_(%class.Args* nonnull %22, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9.9167, i64 0, i64 0), i32 0, i32* nonnull dereferenceable(4) %11, i32* nonnull dereferenceable(4) %7)
          to label %30 unwind label %97

30:                                               ; preds = %28
  %31 = bitcast i32* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %31) #34
  store i32 0, i32* %8, align 4, !tbaa !20283
  invoke fastcc void @_Z21args_base_read_or_setIbiEvP4ArgsPKciRT_RKT0_(%class.Args* nonnull %22, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.12950, i64 0, i64 0), i8* nonnull dereferenceable(1) %4, i32* nonnull dereferenceable(4) %8)
          to label %32 unwind label %101

32:                                               ; preds = %30
  invoke void @_Z14args_base_readIbEvP4ArgsPKciRT_(%class.Args* nonnull %22, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.4.8281, i64 0, i64 0), i32 0, i8* nonnull dereferenceable(1) %5)
          to label %33 unwind label %101

33:                                               ; preds = %32
  %34 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 3
  %35 = bitcast i32* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %35) #34
  store i32 0, i32* %9, align 4, !tbaa !20283
  invoke fastcc void @_Z21args_base_read_or_setIbiEvP4ArgsPKciRT_RKT0_(%class.Args* nonnull %22, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.10.11760, i64 0, i64 0), i8* nonnull dereferenceable(1) %34, i32* nonnull dereferenceable(4) %9)
          to label %36 unwind label %.loopexit.split-lp9

36:                                               ; preds = %33
  %37 = invoke dereferenceable(112) %class.Args* @_ZN4Args5stripEv(%class.Args* nonnull %22)
          to label %.noexc unwind label %.loopexit.split-lp9

.noexc:                                           ; preds = %36
  %38 = getelementptr inbounds %class.Args, %class.Args* %22, i64 0, i32 2
  %39 = load i8, i8* %38, align 2, !tbaa !20301, !range !20292
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %_ZN4Args7consumeEv.exit, label %41

41:                                               ; preds = %.noexc
  %42 = getelementptr inbounds %class.Args, %class.Args* %22, i64 0, i32 6
  %43 = load %"struct.Args::Slot"*, %"struct.Args::Slot"** %42, align 8, !tbaa !20304
  %44 = icmp eq %"struct.Args::Slot"* %43, null
  br i1 %44, label %.loopexit13, label %45

45:                                               ; preds = %41
  %46 = bitcast %"struct.Args::Slot"** %42 to i64*
  br label %50

.loopexit13:                                      ; preds = %.noexc1, %41
  %47 = getelementptr inbounds %class.Args, %class.Args* %22, i64 0, i32 3
  %48 = load i8, i8* %47, align 1, !tbaa !20305
  %49 = icmp eq i8 %48, 0
  br i1 %49, label %.loopexit7, label %.preheader6

50:                                               ; preds = %.noexc1, %45
  %51 = phi %"struct.Args::Slot"* [ %43, %45 ], [ %62, %.noexc1 ]
  %52 = getelementptr inbounds %"struct.Args::Slot", %"struct.Args::Slot"* %51, i64 0, i32 1
  %53 = bitcast %"struct.Args::Slot"** %52 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !20306
  store i64 %54, i64* %46, align 8, !tbaa !20304
  %55 = bitcast %"struct.Args::Slot"* %51 to void (%"struct.Args::Slot"*)***
  %56 = load void (%"struct.Args::Slot"*)**, void (%"struct.Args::Slot"*)*** %55, align 8, !tbaa !20285
  %57 = getelementptr inbounds void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %56, i64 2
  %58 = load void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %57, align 8
  invoke void %58(%"struct.Args::Slot"* nonnull %51)
          to label %.noexc1 unwind label %.loopexit8

.noexc1:                                          ; preds = %50
  %59 = load void (%"struct.Args::Slot"*)**, void (%"struct.Args::Slot"*)*** %55, align 8, !tbaa !20285
  %60 = getelementptr inbounds void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %59, i64 1
  %61 = load void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %60, align 8
  call void %61(%"struct.Args::Slot"* nonnull %51) #34
  %62 = load %"struct.Args::Slot"*, %"struct.Args::Slot"** %42, align 8, !tbaa !20304
  %63 = icmp eq %"struct.Args::Slot"* %62, null
  br i1 %63, label %.loopexit13, label %50

.loopexit7:                                       ; preds = %.preheader6, %.loopexit13
  %64 = getelementptr inbounds %class.Args, %class.Args* %22, i64 0, i32 7, i64 0
  store i8 0, i8* %64, align 8, !tbaa !20287
  store i8 0, i8* %47, align 1, !tbaa !20305
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %35) #34
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %31) #34
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %29) #34
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %6) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %12) #34
  %65 = bitcast %class.Args* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 112, i8* nonnull %65) #34
  %66 = bitcast %class.Args* %10 to %class.CheckIPHeader**
  store %class.CheckIPHeader* %0, %class.CheckIPHeader** %66, align 8, !tbaa !20294
  %67 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 0, i32 1
  store %class.ErrorHandler* %2, %class.ErrorHandler** %67, align 8, !tbaa !20296
  %68 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 0, i32 2
  store i8* null, i8** %68, align 8, !tbaa !20297
  %69 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 0, i32 3
  store i8 0, i8* %69, align 8, !tbaa !20298
  %70 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 5
  %71 = bitcast %class.Vector.2* %70 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %71, i8 0, i64 16, i1 false) #34
  invoke void @_ZN4Args10initializeEPK6VectorI6StringLm16EE(%class.Args* nonnull %10, %class.Vector.0* nonnull %1)
          to label %_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit unwind label %117

.preheader6:                                      ; preds = %.preheader6, %.loopexit13
  %72 = phi i32 [ %89, %.preheader6 ], [ 0, %.loopexit13 ]
  %73 = zext i32 %72 to i64
  %74 = getelementptr inbounds %class.Args, %class.Args* %22, i64 0, i32 7, i64 %73
  %75 = load i8, i8* %74, align 1, !tbaa !20287
  %76 = zext i8 %75 to i32
  %77 = add nuw nsw i32 %72, 1
  %78 = zext i32 %77 to i64
  %79 = getelementptr inbounds %class.Args, %class.Args* %22, i64 0, i32 7, i64 %78
  %80 = add nuw nsw i32 %77, %76
  %81 = zext i32 %80 to i64
  %82 = getelementptr inbounds %class.Args, %class.Args* %22, i64 0, i32 7, i64 %81
  %83 = bitcast i8* %82 to i8**
  %84 = load i8*, i8** %83, align 8, !tbaa !20284
  %85 = zext i8 %75 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %84, i8* nonnull align 1 %79, i64 %85, i1 false)
  %86 = load i8, i8* %74, align 1, !tbaa !20287
  %87 = zext i8 %86 to i32
  %88 = add i32 %72, 9
  %89 = add i32 %88, %87
  %90 = load i8, i8* %47, align 1, !tbaa !20305
  %91 = zext i8 %90 to i32
  %92 = icmp ult i32 %89, %91
  br i1 %92, label %.preheader6, label %.loopexit7

_ZN4Args7consumeEv.exit:                          ; preds = %.noexc
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %35) #34
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %31) #34
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %29) #34
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %6) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %12) #34
  br label %185

93:                                               ; preds = %27, %26, %23, %3
  %94 = landingpad { i8*, i32 }
          cleanup
  %95 = extractvalue { i8*, i32 } %94, 0
  %96 = extractvalue { i8*, i32 } %94, 1
  br label %114

97:                                               ; preds = %28
  %98 = landingpad { i8*, i32 }
          cleanup
  %99 = extractvalue { i8*, i32 } %98, 0
  %100 = extractvalue { i8*, i32 } %98, 1
  br label %111

101:                                              ; preds = %32, %30
  %102 = landingpad { i8*, i32 }
          cleanup
  %103 = extractvalue { i8*, i32 } %102, 0
  %104 = extractvalue { i8*, i32 } %102, 1
  br label %108

.loopexit8:                                       ; preds = %50
  %lpad.loopexit10 = landingpad { i8*, i32 }
          cleanup
  br label %105

.loopexit.split-lp9:                              ; preds = %36, %33
  %lpad.loopexit.split-lp11 = landingpad { i8*, i32 }
          cleanup
  br label %105

105:                                              ; preds = %.loopexit.split-lp9, %.loopexit8
  %lpad.phi12 = phi { i8*, i32 } [ %lpad.loopexit10, %.loopexit8 ], [ %lpad.loopexit.split-lp11, %.loopexit.split-lp9 ]
  %106 = extractvalue { i8*, i32 } %lpad.phi12, 0
  %107 = extractvalue { i8*, i32 } %lpad.phi12, 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %35) #34
  br label %108

108:                                              ; preds = %105, %101
  %109 = phi i8* [ %106, %105 ], [ %103, %101 ]
  %110 = phi i32 [ %107, %105 ], [ %104, %101 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %31) #34
  br label %111

111:                                              ; preds = %108, %97
  %112 = phi i8* [ %109, %108 ], [ %99, %97 ]
  %113 = phi i32 [ %110, %108 ], [ %100, %97 ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %29) #34
  br label %114

114:                                              ; preds = %111, %93
  %115 = phi i8* [ %112, %111 ], [ %95, %93 ]
  %116 = phi i32 [ %113, %111 ], [ %96, %93 ]
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %6) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %12) #34
  br label %187

117:                                              ; preds = %.loopexit7
  %118 = landingpad { i8*, i32 }
          cleanup
  %119 = bitcast %class.Vector.2* %70 to i8**
  %120 = load i8*, i8** %119, align 8, !tbaa !20299
  %121 = icmp eq i8* %120, null
  br i1 %121, label %123, label %122

122:                                              ; preds = %117
  call void @_ZdaPv(i8* nonnull %120) #55
  br label %123

123:                                              ; preds = %122, %117
  resume { i8*, i32 } %118

_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit: ; preds = %.loopexit7
  invoke fastcc void @_Z14args_base_readIN13CheckIPHeader12OldBadSrcArgE6VectorI9IPAddressLm16EEEvP4ArgsPKciT_RT0_(%class.Args* nonnull %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3.4210, i64 0, i64 0), i32 0, %class.Vector.2* nonnull dereferenceable(16) %24)
          to label %124 unwind label %.loopexit.split-lp

124:                                              ; preds = %_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit
  invoke void @_Z14args_base_readIjEvP4ArgsPKciRT_(%class.Args* nonnull %10, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.9.9167, i64 0, i64 0), i32 0, i32* nonnull dereferenceable(4) %11)
          to label %125 unwind label %.loopexit.split-lp

125:                                              ; preds = %124
  invoke void @_ZN4Args14check_completeEv(%class.Args* nonnull %10)
          to label %.noexc2 unwind label %.loopexit.split-lp

.noexc2:                                          ; preds = %125
  %126 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 2
  %127 = load i8, i8* %126, align 2, !tbaa !20301, !range !20292
  %128 = icmp eq i8 %127, 0
  br i1 %128, label %_ZN4Args8completeEv.exit, label %129

129:                                              ; preds = %.noexc2
  %130 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 6
  %131 = load %"struct.Args::Slot"*, %"struct.Args::Slot"** %130, align 8, !tbaa !20304
  %132 = icmp eq %"struct.Args::Slot"* %131, null
  br i1 %132, label %.loopexit5, label %133

133:                                              ; preds = %129
  %134 = bitcast %"struct.Args::Slot"** %130 to i64*
  br label %138

.loopexit5:                                       ; preds = %.noexc3, %129
  %135 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 3
  %136 = load i8, i8* %135, align 1, !tbaa !20305
  %137 = icmp eq i8 %136, 0
  br i1 %137, label %.loopexit, label %.preheader

138:                                              ; preds = %.noexc3, %133
  %139 = phi %"struct.Args::Slot"* [ %131, %133 ], [ %150, %.noexc3 ]
  %140 = getelementptr inbounds %"struct.Args::Slot", %"struct.Args::Slot"* %139, i64 0, i32 1
  %141 = bitcast %"struct.Args::Slot"** %140 to i64*
  %142 = load i64, i64* %141, align 8, !tbaa !20306
  store i64 %142, i64* %134, align 8, !tbaa !20304
  %143 = bitcast %"struct.Args::Slot"* %139 to void (%"struct.Args::Slot"*)***
  %144 = load void (%"struct.Args::Slot"*)**, void (%"struct.Args::Slot"*)*** %143, align 8, !tbaa !20285
  %145 = getelementptr inbounds void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %144, i64 2
  %146 = load void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %145, align 8
  invoke void %146(%"struct.Args::Slot"* nonnull %139)
          to label %.noexc3 unwind label %.loopexit4

.noexc3:                                          ; preds = %138
  %147 = load void (%"struct.Args::Slot"*)**, void (%"struct.Args::Slot"*)*** %143, align 8, !tbaa !20285
  %148 = getelementptr inbounds void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %147, i64 1
  %149 = load void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %148, align 8
  call void %149(%"struct.Args::Slot"* nonnull %139) #34
  %150 = load %"struct.Args::Slot"*, %"struct.Args::Slot"** %130, align 8, !tbaa !20304
  %151 = icmp eq %"struct.Args::Slot"* %150, null
  br i1 %151, label %.loopexit5, label %138

.loopexit:                                        ; preds = %.preheader, %.loopexit5
  %152 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 7, i64 0
  store i8 0, i8* %152, align 8, !tbaa !20287
  store i8 0, i8* %135, align 1, !tbaa !20305
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %10) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %65) #34
  %153 = load i8, i8* %4, align 1, !tbaa !20338, !range !20292
  %154 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 4
  store i8 %153, i8* %154, align 1, !tbaa !23491
  %155 = load i8, i8* %5, align 1, !tbaa !20338, !range !20292
  %156 = icmp eq i8 %155, 0
  br i1 %156, label %185, label %181

.preheader:                                       ; preds = %.preheader, %.loopexit5
  %157 = phi i32 [ %174, %.preheader ], [ 0, %.loopexit5 ]
  %158 = zext i32 %157 to i64
  %159 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 7, i64 %158
  %160 = load i8, i8* %159, align 1, !tbaa !20287
  %161 = zext i8 %160 to i32
  %162 = add nuw nsw i32 %157, 1
  %163 = zext i32 %162 to i64
  %164 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 7, i64 %163
  %165 = add nuw nsw i32 %162, %161
  %166 = zext i32 %165 to i64
  %167 = getelementptr inbounds %class.Args, %class.Args* %10, i64 0, i32 7, i64 %166
  %168 = bitcast i8* %167 to i8**
  %169 = load i8*, i8** %168, align 8, !tbaa !20284
  %170 = zext i8 %160 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %169, i8* nonnull align 1 %164, i64 %170, i1 false)
  %171 = load i8, i8* %159, align 1, !tbaa !20287
  %172 = zext i8 %171 to i32
  %173 = add i32 %157, 9
  %174 = add i32 %173, %172
  %175 = load i8, i8* %135, align 1, !tbaa !20305
  %176 = zext i8 %175 to i32
  %177 = icmp ult i32 %174, %176
  br i1 %177, label %.preheader, label %.loopexit

_ZN4Args8completeEv.exit:                         ; preds = %.noexc2
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %10) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %65) #34
  br label %185

.loopexit4:                                       ; preds = %138
  %lpad.loopexit = landingpad { i8*, i32 }
          cleanup
  br label %178

.loopexit.split-lp:                               ; preds = %125, %124, %_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit
  %lpad.loopexit.split-lp = landingpad { i8*, i32 }
          cleanup
  br label %178

178:                                              ; preds = %.loopexit.split-lp, %.loopexit4
  %lpad.phi = phi { i8*, i32 } [ %lpad.loopexit, %.loopexit4 ], [ %lpad.loopexit.split-lp, %.loopexit.split-lp ]
  %179 = extractvalue { i8*, i32 } %lpad.phi, 0
  %180 = extractvalue { i8*, i32 } %lpad.phi, 1
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %10) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %65) #34
  br label %187

181:                                              ; preds = %.loopexit
  %182 = call dereferenceable(96) i8* @_Znam(i64 96) #56
  %183 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 9
  %184 = bitcast %class.atomic_uint64_t** %183 to i8**
  store i8* %182, i8** %184, align 16, !tbaa !23484
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 dereferenceable(96) %182, i8 0, i64 96, i1 false)
  br label %185

185:                                              ; preds = %181, %_ZN4Args8completeEv.exit, %.loopexit, %_ZN4Args7consumeEv.exit
  %186 = phi i32 [ -1, %_ZN4Args7consumeEv.exit ], [ -1, %_ZN4Args8completeEv.exit ], [ 0, %.loopexit ], [ 0, %181 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #34
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %4) #34
  ret i32 %186

187:                                              ; preds = %178, %114
  %188 = phi i8* [ %179, %178 ], [ %115, %114 ]
  %189 = phi i32 [ %180, %178 ], [ %116, %114 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #34
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %4) #34
  %190 = insertvalue { i8*, i32 } undef, i8* %188, 0
  %191 = insertvalue { i8*, i32 } %190, i32 %189, 1
  resume { i8*, i32 } %191
}

define dso_local void @_ZN13CheckIPHeader12add_handlersEv(%class.CheckIPHeader* readonly %0) unnamed_addr #0 align 2 {
  %2 = bitcast %class.CheckIPHeader* %0 to %class.Element*
  tail call void @_ZN7Element16add_read_handlerEPKcPF6StringPS_PvEij(%class.Element* %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.27.12883, i64 0, i64 0), void (%class.String*, %class.Element*, i8*)* nonnull @_ZN13CheckIPHeader12read_handlerEP7ElementPv, i32 0, i32 0)
  tail call void @_ZN7Element16add_read_handlerEPKcPF6StringPS_PvEij(%class.Element* %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8.12921, i64 0, i64 0), void (%class.String*, %class.Element*, i8*)* nonnull @_ZN13CheckIPHeader12read_handlerEP7ElementPv, i32 1, i32 0)
  %3 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 9
  %4 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %3, align 16, !tbaa !23484
  %5 = icmp eq %class.atomic_uint64_t* %4, null
  br i1 %5, label %7, label %6

6:                                                ; preds = %1
  tail call void @_ZN7Element16add_read_handlerEPKcPF6StringPS_PvEij(%class.Element* %2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.14.8271, i64 0, i64 0), void (%class.String*, %class.Element*, i8*)* nonnull @_ZN13CheckIPHeader12read_handlerEP7ElementPv, i32 2, i32 0)
  br label %7

7:                                                ; preds = %6, %1
  ret void
}

define dso_local void @_ZN13CheckIPHeader12read_handlerEP7ElementPv(%class.String* noalias nocapture sret %0, %class.Element* %1, i8* %2) #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  %4 = alloca %class.StringAccum, align 8
  %5 = ptrtoint i8* %2 to i64
  switch i64 %5, label %68 [
    i64 0, label %6
    i64 1, label %10
    i64 2, label %14
  ]

6:                                                ; preds = %3
  %7 = getelementptr inbounds %class.Element, %class.Element* %1, i64 1, i32 5, i64 1
  %8 = bitcast %"class.Element::Port"* %7 to i64*
  %9 = load volatile i64, i64* %8, align 16, !tbaa !20964
  tail call void @_ZN6StringC2Em(%class.String* %0, i64 %9)
  br label %72

10:                                               ; preds = %3
  %11 = getelementptr inbounds %class.Element, %class.Element* %1, i64 1, i32 5, i64 2
  %12 = bitcast %"class.Element::Port"* %11 to i64*
  %13 = load volatile i64, i64* %12, align 16, !tbaa !20964
  tail call void @_ZN6StringC2Em(%class.String* %0, i64 %13)
  br label %72

14:                                               ; preds = %3
  %15 = bitcast %class.StringAccum* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %15) #34
  %16 = getelementptr inbounds %class.StringAccum, %class.StringAccum* %4, i64 0, i32 0, i32 0
  store i8* @_ZN6String9null_dataE, i8** %16, align 8, !tbaa !20504
  %17 = getelementptr inbounds %class.StringAccum, %class.StringAccum* %4, i64 0, i32 0, i32 1
  store i32 0, i32* %17, align 8, !tbaa !20506
  %18 = getelementptr inbounds %class.StringAccum, %class.StringAccum* %4, i64 0, i32 0, i32 2
  store i32 0, i32* %18, align 4, !tbaa !20507
  %19 = getelementptr inbounds %class.Element, %class.Element* %1, i64 1, i32 5, i64 3
  %20 = bitcast %"class.Element::Port"* %19 to %class.atomic_uint64_t**
  %21 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %20, align 16, !tbaa !23484
  %22 = getelementptr inbounds %class.atomic_uint64_t, %class.atomic_uint64_t* %21, i64 0, i32 0
  %23 = load volatile i64, i64* %22, align 16, !tbaa !20964
  %24 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.8272, i64 0, i64 0), i64 %23)
          to label %25 unwind label %60

25:                                               ; preds = %14
  %26 = load i32, i32* %17, align 8, !tbaa !20508
  %27 = add nsw i32 %26, 17
  %28 = load i32, i32* %18, align 4, !tbaa !20513
  %29 = icmp sgt i32 %27, %28
  br i1 %29, label %34, label %30

30:                                               ; preds = %25
  %31 = load i8*, i8** %16, align 8, !tbaa !20514
  %32 = sext i32 %26 to i64
  %33 = getelementptr inbounds i8, i8* %31, i64 %32
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(17) %33, i8* nonnull align 1 dereferenceable(17) getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i64 17, i1 false)
  store i32 %27, i32* %17, align 8, !tbaa !20508
  br label %35

34:                                               ; preds = %25
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i32 17)
          to label %35 unwind label %60

35:                                               ; preds = %34, %30
  %36 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9.8274, i64 0, i64 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.3772, i64 0, i64 0))
          to label %37 unwind label %60

37:                                               ; preds = %35
  %38 = load i32, i32* %17, align 8, !tbaa !20508
  %39 = load i32, i32* %18, align 4, !tbaa !20513
  %40 = icmp slt i32 %38, %39
  br i1 %40, label %41, label %47

41:                                               ; preds = %37
  %42 = load i8*, i8** %16, align 8, !tbaa !20514
  %43 = sext i32 %38 to i64
  %44 = getelementptr inbounds i8, i8* %42, i64 %43
  store i8 10, i8* %44, align 1
  %45 = load i32, i32* %17, align 8, !tbaa !20508
  %46 = add nsw i32 %45, 1
  store i32 %46, i32* %17, align 8, !tbaa !20508
  br label %48

47:                                               ; preds = %37
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110.15895, i64 0, i64 0), i32 1)
          to label %48 unwind label %60

48:                                               ; preds = %47, %41
  %49 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %20, align 16, !tbaa !23484
  %50 = getelementptr inbounds %class.atomic_uint64_t, %class.atomic_uint64_t* %49, i64 1, i32 0
  %51 = load volatile i64, i64* %50, align 16, !tbaa !20964
  %52 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.8272, i64 0, i64 0), i64 %51)
          to label %73 unwind label %60

53:                                               ; preds = %232, %_ZN6String10make_claimEPcii.exit.i
  %54 = phi i32 [ %210, %232 ], [ %.pre12, %_ZN6String10make_claimEPcii.exit.i ]
  %55 = icmp sgt i32 %54, 0
  br i1 %55, label %56, label %59

56:                                               ; preds = %53
  %57 = load i8*, i8** %16, align 8, !tbaa !20514
  %58 = getelementptr inbounds i8, i8* %57, i64 -12
  call void @_ZdaPv(i8* nonnull %58) #55
  br label %59

59:                                               ; preds = %.thread, %56, %53
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %15) #34
  br label %72

60:                                               ; preds = %201, %195, %194, %180, %173, %167, %166, %152, %145, %139, %138, %124, %117, %111, %110, %96, %89, %83, %82, %48, %47, %35, %34, %14
  %61 = landingpad { i8*, i32 }
          cleanup
  %62 = load i32, i32* %18, align 4, !tbaa !20513
  %63 = icmp sgt i32 %62, 0
  br i1 %63, label %64, label %67

64:                                               ; preds = %60
  %65 = load i8*, i8** %16, align 8, !tbaa !20514
  %66 = getelementptr inbounds i8, i8* %65, i64 -12
  call void @_ZdaPv(i8* nonnull %66) #55
  br label %67

67:                                               ; preds = %64, %60
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %15) #34
  resume { i8*, i32 } %61

68:                                               ; preds = %3
  %69 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 0
  store i8* @_ZN6String9null_dataE, i8** %69, align 8, !tbaa !20330
  %70 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 1
  store i32 0, i32* %70, align 8, !tbaa !20308
  %71 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 2
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %71, align 8, !tbaa !20316
  br label %72

72:                                               ; preds = %68, %59, %10, %6
  ret void

73:                                               ; preds = %48
  %74 = load i32, i32* %17, align 8, !tbaa !20508
  %75 = add nsw i32 %74, 17
  %76 = load i32, i32* %18, align 4, !tbaa !20513
  %77 = icmp sgt i32 %75, %76
  br i1 %77, label %82, label %78

78:                                               ; preds = %73
  %79 = load i8*, i8** %16, align 8, !tbaa !20514
  %80 = sext i32 %74 to i64
  %81 = getelementptr inbounds i8, i8* %79, i64 %80
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(17) %81, i8* nonnull align 1 dereferenceable(17) getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i64 17, i1 false)
  store i32 %75, i32* %17, align 8, !tbaa !20508
  br label %83

82:                                               ; preds = %73
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i32 17)
          to label %83 unwind label %60

83:                                               ; preds = %82, %78
  %84 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9.8274, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.3774, i64 0, i64 0))
          to label %85 unwind label %60

85:                                               ; preds = %83
  %86 = load i32, i32* %17, align 8, !tbaa !20508
  %87 = load i32, i32* %18, align 4, !tbaa !20513
  %88 = icmp slt i32 %86, %87
  br i1 %88, label %90, label %89

89:                                               ; preds = %85
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110.15895, i64 0, i64 0), i32 1)
          to label %96 unwind label %60

90:                                               ; preds = %85
  %91 = load i8*, i8** %16, align 8, !tbaa !20514
  %92 = sext i32 %86 to i64
  %93 = getelementptr inbounds i8, i8* %91, i64 %92
  store i8 10, i8* %93, align 1
  %94 = load i32, i32* %17, align 8, !tbaa !20508
  %95 = add nsw i32 %94, 1
  store i32 %95, i32* %17, align 8, !tbaa !20508
  br label %96

96:                                               ; preds = %90, %89
  %97 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %20, align 16, !tbaa !23484
  %98 = getelementptr inbounds %class.atomic_uint64_t, %class.atomic_uint64_t* %97, i64 2, i32 0
  %99 = load volatile i64, i64* %98, align 16, !tbaa !20964
  %100 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.8272, i64 0, i64 0), i64 %99)
          to label %101 unwind label %60

101:                                              ; preds = %96
  %102 = load i32, i32* %17, align 8, !tbaa !20508
  %103 = add nsw i32 %102, 17
  %104 = load i32, i32* %18, align 4, !tbaa !20513
  %105 = icmp sgt i32 %103, %104
  br i1 %105, label %110, label %106

106:                                              ; preds = %101
  %107 = load i8*, i8** %16, align 8, !tbaa !20514
  %108 = sext i32 %102 to i64
  %109 = getelementptr inbounds i8, i8* %107, i64 %108
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(17) %109, i8* nonnull align 1 dereferenceable(17) getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i64 17, i1 false)
  store i32 %103, i32* %17, align 8, !tbaa !20508
  br label %111

110:                                              ; preds = %101
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i32 17)
          to label %111 unwind label %60

111:                                              ; preds = %110, %106
  %112 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9.8274, i64 0, i64 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.2.3775, i64 0, i64 0))
          to label %113 unwind label %60

113:                                              ; preds = %111
  %114 = load i32, i32* %17, align 8, !tbaa !20508
  %115 = load i32, i32* %18, align 4, !tbaa !20513
  %116 = icmp slt i32 %114, %115
  br i1 %116, label %118, label %117

117:                                              ; preds = %113
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110.15895, i64 0, i64 0), i32 1)
          to label %124 unwind label %60

118:                                              ; preds = %113
  %119 = load i8*, i8** %16, align 8, !tbaa !20514
  %120 = sext i32 %114 to i64
  %121 = getelementptr inbounds i8, i8* %119, i64 %120
  store i8 10, i8* %121, align 1
  %122 = load i32, i32* %17, align 8, !tbaa !20508
  %123 = add nsw i32 %122, 1
  store i32 %123, i32* %17, align 8, !tbaa !20508
  br label %124

124:                                              ; preds = %118, %117
  %125 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %20, align 16, !tbaa !23484
  %126 = getelementptr inbounds %class.atomic_uint64_t, %class.atomic_uint64_t* %125, i64 3, i32 0
  %127 = load volatile i64, i64* %126, align 16, !tbaa !20964
  %128 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.8272, i64 0, i64 0), i64 %127)
          to label %129 unwind label %60

129:                                              ; preds = %124
  %130 = load i32, i32* %17, align 8, !tbaa !20508
  %131 = add nsw i32 %130, 17
  %132 = load i32, i32* %18, align 4, !tbaa !20513
  %133 = icmp sgt i32 %131, %132
  br i1 %133, label %138, label %134

134:                                              ; preds = %129
  %135 = load i8*, i8** %16, align 8, !tbaa !20514
  %136 = sext i32 %130 to i64
  %137 = getelementptr inbounds i8, i8* %135, i64 %136
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(17) %137, i8* nonnull align 1 dereferenceable(17) getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i64 17, i1 false)
  store i32 %131, i32* %17, align 8, !tbaa !20508
  br label %139

138:                                              ; preds = %129
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i32 17)
          to label %139 unwind label %60

139:                                              ; preds = %138, %134
  %140 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9.8274, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.3.3776, i64 0, i64 0))
          to label %141 unwind label %60

141:                                              ; preds = %139
  %142 = load i32, i32* %17, align 8, !tbaa !20508
  %143 = load i32, i32* %18, align 4, !tbaa !20513
  %144 = icmp slt i32 %142, %143
  br i1 %144, label %146, label %145

145:                                              ; preds = %141
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110.15895, i64 0, i64 0), i32 1)
          to label %152 unwind label %60

146:                                              ; preds = %141
  %147 = load i8*, i8** %16, align 8, !tbaa !20514
  %148 = sext i32 %142 to i64
  %149 = getelementptr inbounds i8, i8* %147, i64 %148
  store i8 10, i8* %149, align 1
  %150 = load i32, i32* %17, align 8, !tbaa !20508
  %151 = add nsw i32 %150, 1
  store i32 %151, i32* %17, align 8, !tbaa !20508
  br label %152

152:                                              ; preds = %146, %145
  %153 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %20, align 16, !tbaa !23484
  %154 = getelementptr inbounds %class.atomic_uint64_t, %class.atomic_uint64_t* %153, i64 4, i32 0
  %155 = load volatile i64, i64* %154, align 16, !tbaa !20964
  %156 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.8272, i64 0, i64 0), i64 %155)
          to label %157 unwind label %60

157:                                              ; preds = %152
  %158 = load i32, i32* %17, align 8, !tbaa !20508
  %159 = add nsw i32 %158, 17
  %160 = load i32, i32* %18, align 4, !tbaa !20513
  %161 = icmp sgt i32 %159, %160
  br i1 %161, label %166, label %162

162:                                              ; preds = %157
  %163 = load i8*, i8** %16, align 8, !tbaa !20514
  %164 = sext i32 %158 to i64
  %165 = getelementptr inbounds i8, i8* %163, i64 %164
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(17) %165, i8* nonnull align 1 dereferenceable(17) getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i64 17, i1 false)
  store i32 %159, i32* %17, align 8, !tbaa !20508
  br label %167

166:                                              ; preds = %157
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i32 17)
          to label %167 unwind label %60

167:                                              ; preds = %166, %162
  %168 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9.8274, i64 0, i64 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4.3777, i64 0, i64 0))
          to label %169 unwind label %60

169:                                              ; preds = %167
  %170 = load i32, i32* %17, align 8, !tbaa !20508
  %171 = load i32, i32* %18, align 4, !tbaa !20513
  %172 = icmp slt i32 %170, %171
  br i1 %172, label %174, label %173

173:                                              ; preds = %169
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110.15895, i64 0, i64 0), i32 1)
          to label %180 unwind label %60

174:                                              ; preds = %169
  %175 = load i8*, i8** %16, align 8, !tbaa !20514
  %176 = sext i32 %170 to i64
  %177 = getelementptr inbounds i8, i8* %175, i64 %176
  store i8 10, i8* %177, align 1
  %178 = load i32, i32* %17, align 8, !tbaa !20508
  %179 = add nsw i32 %178, 1
  store i32 %179, i32* %17, align 8, !tbaa !20508
  br label %180

180:                                              ; preds = %174, %173
  %181 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %20, align 16, !tbaa !23484
  %182 = getelementptr inbounds %class.atomic_uint64_t, %class.atomic_uint64_t* %181, i64 5, i32 0
  %183 = load volatile i64, i64* %182, align 16, !tbaa !20964
  %184 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 15, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7.8272, i64 0, i64 0), i64 %183)
          to label %185 unwind label %60

185:                                              ; preds = %180
  %186 = load i32, i32* %17, align 8, !tbaa !20508
  %187 = add nsw i32 %186, 17
  %188 = load i32, i32* %18, align 4, !tbaa !20513
  %189 = icmp sgt i32 %187, %188
  br i1 %189, label %194, label %190

190:                                              ; preds = %185
  %191 = load i8*, i8** %16, align 8, !tbaa !20514
  %192 = sext i32 %186 to i64
  %193 = getelementptr inbounds i8, i8* %191, i64 %192
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(17) %193, i8* nonnull align 1 dereferenceable(17) getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i64 17, i1 false)
  store i32 %187, i32* %17, align 8, !tbaa !20508
  br label %195

194:                                              ; preds = %185
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([18 x i8], [18 x i8]* @.str.8.8273, i64 0, i64 0), i32 17)
          to label %195 unwind label %60

195:                                              ; preds = %194, %190
  %196 = invoke dereferenceable(16) %class.StringAccum* (%class.StringAccum*, i32, i8*, ...) @_ZN11StringAccum8snprintfEiPKcz(%class.StringAccum* nonnull %4, i32 24, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9.8274, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.10.4806, i64 0, i64 0))
          to label %197 unwind label %60

197:                                              ; preds = %195
  %198 = load i32, i32* %17, align 8, !tbaa !20508
  %199 = load i32, i32* %18, align 4, !tbaa !20513
  %200 = icmp slt i32 %198, %199
  br i1 %200, label %202, label %201

201:                                              ; preds = %197
  invoke void @_ZN11StringAccum11hard_appendEPKci(%class.StringAccum* nonnull %4, i8* nonnull getelementptr inbounds ([2 x i8], [2 x i8]* @.str.110.15895, i64 0, i64 0), i32 1)
          to label %._crit_edge unwind label %60

._crit_edge:                                      ; preds = %201
  %.pre = load i32, i32* %17, align 8, !tbaa !20508, !noalias !23492
  br label %208

202:                                              ; preds = %197
  %203 = load i8*, i8** %16, align 8, !tbaa !20514
  %204 = sext i32 %198 to i64
  %205 = getelementptr inbounds i8, i8* %203, i64 %204
  store i8 10, i8* %205, align 1
  %206 = load i32, i32* %17, align 8, !tbaa !20508
  %207 = add nsw i32 %206, 1
  store i32 %207, i32* %17, align 8, !tbaa !20508
  br label %208

208:                                              ; preds = %202, %._crit_edge
  %209 = phi i32 [ %.pre, %._crit_edge ], [ %207, %202 ]
  %210 = load i32, i32* %18, align 4, !tbaa !20513, !noalias !23492
  %211 = icmp sgt i32 %209, 0
  %212 = icmp sgt i32 %210, 0
  %213 = and i1 %211, %212
  br i1 %213, label %214, label %230

214:                                              ; preds = %208
  %215 = load i8*, i8** %16, align 8, !tbaa !20514, !noalias !23492
  store i8* @_ZN6String9null_dataE, i8** %16, align 8, !tbaa.struct !20515, !noalias !23492
  store i32 0, i32* %17, align 8, !tbaa.struct !20515, !noalias !23492
  store i32 0, i32* %18, align 4, !tbaa.struct !20515, !noalias !23492
  %216 = icmp eq i8* %215, null
  %217 = icmp slt i32 %210, %209
  %218 = or i1 %216, %217
  br i1 %218, label %219, label %_ZN6String10make_claimEPcii.exit.i

219:                                              ; preds = %214
  call void @__assert_fail(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.10.13525, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 325, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @__PRETTY_FUNCTION__._ZN6String10make_claimEPcii, i64 0, i64 0)) #57, !noalias !23495
  unreachable

_ZN6String10make_claimEPcii.exit.i:               ; preds = %214
  %220 = getelementptr inbounds i8, i8* %215, i64 -12
  %221 = getelementptr inbounds i8, i8* %215, i64 -8
  %222 = bitcast i8* %221 to i32*
  store i32 %210, i32* %222, align 4, !tbaa !20320, !noalias !23495
  %223 = getelementptr inbounds i8, i8* %215, i64 -4
  %224 = bitcast i8* %223 to i32*
  store volatile i32 %209, i32* %224, align 4, !tbaa !20321, !noalias !23495
  %225 = bitcast i8* %220 to i32*
  store volatile i32 0, i32* %225, align 4, !tbaa !20317, !noalias !23495
  %226 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 0
  store i8* %215, i8** %226, align 8, !tbaa !20330, !alias.scope !23495
  %227 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 1
  store i32 %209, i32* %227, align 8, !tbaa !20308, !alias.scope !23495
  %228 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 2
  %229 = bitcast %"struct.String::memo_t"** %228 to i8**
  store i8* %220, i8** %229, align 8, !tbaa !20316, !alias.scope !23495
  call void asm sideeffect "lock ; incl $0", "=*m,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %225, i32* nonnull %225) #34, !noalias !23495, !srcloc !20519
  %.pre12 = load i32, i32* %18, align 4, !tbaa !20513
  br label %53

230:                                              ; preds = %208
  %231 = icmp slt i32 %210, 0
  br i1 %231, label %.thread, label %232

232:                                              ; preds = %230
  %233 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 0
  store i8* @_ZN6String9null_dataE, i8** %233, align 8, !tbaa !20330, !alias.scope !23492
  %234 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 1
  store i32 0, i32* %234, align 8, !tbaa !20308, !alias.scope !23492
  %235 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 2
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %235, align 8, !tbaa !20316, !alias.scope !23492
  br label %53

.thread:                                          ; preds = %230
  store i32 0, i32* %18, align 4, !tbaa !20513, !noalias !23492
  store i32 0, i32* %17, align 8, !tbaa !20508, !noalias !23492
  %236 = bitcast %class.String* %0 to i64*
  store i64 ptrtoint ([15 x i8]* @_ZN6String8oom_dataE to i64), i64* %236, align 8, !tbaa !20330, !alias.scope !23492
  %237 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 1
  store i32 14, i32* %237, align 8, !tbaa !20308, !alias.scope !23492
  %238 = getelementptr inbounds %class.String, %class.String* %0, i64 0, i32 0, i32 2
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %238, align 8, !tbaa !20316, !alias.scope !23492
  br label %59
}

define dso_local noalias %class.Packet* @_ZN13CheckIPHeader4dropENS_6ReasonEP6Packetb(%class.CheckIPHeader* %0, i32 %1, %class.Packet* %2, i1 zeroext %3) local_unnamed_addr #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  %5 = alloca i8, align 1
  %6 = alloca i8, align 1
  %7 = alloca i8, align 1
  %8 = alloca %class.String, align 8
  %9 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 8, i32 0
  %10 = load volatile i64, i64* %9, align 16, !tbaa !20964
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %16, label %12

12:                                               ; preds = %4
  %13 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 4
  %14 = load i8, i8* %13, align 1, !tbaa !23491, !range !20292
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %110, label %16

16:                                               ; preds = %12, %4
  %17 = bitcast %class.String* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %17) #34
  %18 = bitcast %class.CheckIPHeader* %0 to %class.Element*
  call void @_ZNK7Element4nameEv(%class.String* nonnull sret %8, %class.Element* %18)
  %19 = getelementptr inbounds %class.String, %class.String* %8, i64 0, i32 0, i32 0
  %20 = load i8*, i8** %19, align 8, !tbaa !20330
  %21 = getelementptr inbounds %class.String, %class.String* %8, i64 0, i32 0, i32 1
  %22 = load i32, i32* %21, align 8, !tbaa !20308
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i8, i8* %20, i64 %23
  %25 = getelementptr inbounds %class.String, %class.String* %8, i64 0, i32 0, i32 2
  %26 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %25, align 8, !tbaa !20316
  %27 = icmp eq %"struct.String::memo_t"* %26, null
  br i1 %27, label %34, label %28

28:                                               ; preds = %16
  %29 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %26, i64 0, i32 2
  %30 = load volatile i32, i32* %29, align 4, !tbaa !20321
  %31 = zext i32 %30 to i64
  %32 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %26, i64 0, i32 3, i64 %31
  %33 = icmp ult i8* %24, %32
  br i1 %33, label %34, label %37

34:                                               ; preds = %28, %16
  %35 = load i8, i8* %24, align 1, !tbaa !20287
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %44, label %37

37:                                               ; preds = %34, %28
  %38 = invoke i8* @_ZN6String20append_uninitializedEi(%class.String* nonnull %8, i32 1)
          to label %39 unwind label %79

39:                                               ; preds = %37
  %40 = icmp eq i8* %38, null
  br i1 %40, label %44, label %41

41:                                               ; preds = %39
  store i8 0, i8* %38, align 1, !tbaa !20287
  %42 = load i32, i32* %21, align 8, !tbaa !20308
  %43 = add nsw i32 %42, -1
  store i32 %43, i32* %21, align 8, !tbaa !20308
  br label %44

44:                                               ; preds = %41, %39, %34
  %45 = load i8*, i8** %19, align 8, !tbaa !20330
  %46 = zext i32 %1 to i64
  %47 = getelementptr inbounds [6 x i8*], [6 x i8*]* @_ZN13CheckIPHeader12reason_textsE, i64 0, i64 %46
  %48 = load i8*, i8** %47, align 8, !tbaa !20284
  invoke void (i8*, ...) @click_chatter(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.14.3787, i64 0, i64 0), i8* %45, i8* %48)
          to label %49 unwind label %79

49:                                               ; preds = %44
  %50 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %25, align 8, !tbaa !20316
  %51 = icmp eq %"struct.String::memo_t"* %50, null
  br i1 %51, label %78, label %52

52:                                               ; preds = %49
  %53 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %50, i64 0, i32 0
  %54 = load volatile i32, i32* %53, align 4, !tbaa !20317
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %56, label %57

56:                                               ; preds = %52
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4.16721, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.16722, i64 0, i64 0), i32 289, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__PRETTY_FUNCTION__._ZNK6String5derefEv.16723, i64 0, i64 0)) #57
  unreachable

57:                                               ; preds = %52
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %6) #34
  call void asm sideeffect "lock ; decl $0 ; sete $1", "=*m,=*qm,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %53, i8* nonnull %6, i32* nonnull %53) #34, !srcloc !23488
  %58 = load i8, i8* %6, align 1, !tbaa !20287
  %59 = icmp eq i8 %58, 0
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %6) #34
  br i1 %59, label %77, label %60

60:                                               ; preds = %57
  %61 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %25, align 8, !tbaa !20316
  %62 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %61, i64 0, i32 0
  %63 = load volatile i32, i32* %62, align 4, !tbaa !20317
  %64 = icmp eq i32 %63, 0
  br i1 %64, label %66, label %65

65:                                               ; preds = %60
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.13507, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 133, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

66:                                               ; preds = %60
  %67 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %61, i64 0, i32 1
  %68 = load i32, i32* %67, align 4, !tbaa !20320
  %69 = icmp eq i32 %68, 0
  br i1 %69, label %70, label %71

70:                                               ; preds = %66
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.13508, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 134, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

71:                                               ; preds = %66
  %72 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %61, i64 0, i32 2
  %73 = load volatile i32, i32* %72, align 4, !tbaa !20321
  %74 = icmp ult i32 %68, %73
  br i1 %74, label %75, label %_ZN6String11delete_memoEPNS_6memo_tE.exit

75:                                               ; preds = %71
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.13509, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 135, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

_ZN6String11delete_memoEPNS_6memo_tE.exit:        ; preds = %71
  %76 = bitcast %"struct.String::memo_t"* %61 to i8*
  call void @_ZdaPv(i8* %76) #55
  br label %77

77:                                               ; preds = %_ZN6String11delete_memoEPNS_6memo_tE.exit, %57
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %25, align 8, !tbaa !20316
  br label %78

78:                                               ; preds = %77, %49
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %17) #34
  br label %110

79:                                               ; preds = %44, %37
  %80 = landingpad { i8*, i32 }
          cleanup
  %81 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %25, align 8, !tbaa !20316
  %82 = icmp eq %"struct.String::memo_t"* %81, null
  br i1 %82, label %109, label %83

83:                                               ; preds = %79
  %84 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %81, i64 0, i32 0
  %85 = load volatile i32, i32* %84, align 4, !tbaa !20317
  %86 = icmp eq i32 %85, 0
  br i1 %86, label %87, label %88

87:                                               ; preds = %83
  call void @__assert_fail(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.4.16721, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.5.16722, i64 0, i64 0), i32 289, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__PRETTY_FUNCTION__._ZNK6String5derefEv.16723, i64 0, i64 0)) #57
  unreachable

88:                                               ; preds = %83
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %5) #34
  call void asm sideeffect "lock ; decl $0 ; sete $1", "=*m,=*qm,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* nonnull %84, i8* nonnull %5, i32* nonnull %84) #34, !srcloc !23488
  %89 = load i8, i8* %5, align 1, !tbaa !20287
  %90 = icmp eq i8 %89, 0
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %5) #34
  br i1 %90, label %108, label %91

91:                                               ; preds = %88
  %92 = load %"struct.String::memo_t"*, %"struct.String::memo_t"** %25, align 8, !tbaa !20316
  %93 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %92, i64 0, i32 0
  %94 = load volatile i32, i32* %93, align 4, !tbaa !20317
  %95 = icmp eq i32 %94, 0
  br i1 %95, label %97, label %96

96:                                               ; preds = %91
  call void @__assert_fail(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2.13507, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 133, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

97:                                               ; preds = %91
  %98 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %92, i64 0, i32 1
  %99 = load i32, i32* %98, align 4, !tbaa !20320
  %100 = icmp eq i32 %99, 0
  br i1 %100, label %101, label %102

101:                                              ; preds = %97
  call void @__assert_fail(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.13508, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 134, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

102:                                              ; preds = %97
  %103 = getelementptr inbounds %"struct.String::memo_t", %"struct.String::memo_t"* %92, i64 0, i32 2
  %104 = load volatile i32, i32* %103, align 4, !tbaa !20321
  %105 = icmp ult i32 %99, %104
  br i1 %105, label %106, label %_ZN6String11delete_memoEPNS_6memo_tE.exit7

106:                                              ; preds = %102
  call void @__assert_fail(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.4.13509, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1.13504, i64 0, i64 0), i32 135, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @__PRETTY_FUNCTION__._ZN6String11delete_memoEPNS_6memo_tE, i64 0, i64 0)) #57
  unreachable

_ZN6String11delete_memoEPNS_6memo_tE.exit7:       ; preds = %102
  %107 = bitcast %"struct.String::memo_t"* %92 to i8*
  call void @_ZdaPv(i8* %107) #55
  br label %108

108:                                              ; preds = %_ZN6String11delete_memoEPNS_6memo_tE.exit7, %88
  store %"struct.String::memo_t"* null, %"struct.String::memo_t"** %25, align 8, !tbaa !20316
  br label %109

109:                                              ; preds = %108, %79
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %17) #34
  resume { i8*, i32 } %80

110:                                              ; preds = %78, %12
  call void asm sideeffect "lock ; incq $0", "=*m,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i64* nonnull %9, i64* nonnull %9) #34, !srcloc !23490
  %111 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 9
  %112 = load %class.atomic_uint64_t*, %class.atomic_uint64_t** %111, align 16, !tbaa !23484
  %113 = icmp eq %class.atomic_uint64_t* %112, null
  br i1 %113, label %117, label %114

114:                                              ; preds = %110
  %115 = zext i32 %1 to i64
  %116 = getelementptr inbounds %class.atomic_uint64_t, %class.atomic_uint64_t* %112, i64 %115, i32 0
  call void asm sideeffect "lock ; incq $0", "=*m,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i64* nonnull %116, i64* nonnull %116) #34, !srcloc !23490
  br label %117

117:                                              ; preds = %114, %110
  %118 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 6, i64 1
  %119 = load i32, i32* %118, align 4, !tbaa !20283
  %120 = icmp eq i32 %119, 2
  br i1 %120, label %121, label %137

121:                                              ; preds = %117
  %122 = getelementptr inbounds %class.CheckIPHeader, %class.CheckIPHeader* %0, i64 0, i32 0, i32 0, i32 0, i32 4, i64 1
  %123 = load %"class.Element::Port"*, %"class.Element::Port"** %122, align 8, !tbaa !20284
  %124 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %123, i64 1, i32 0
  %125 = load %class.Element*, %class.Element** %124, align 8, !tbaa !20278
  %126 = icmp ne %class.Element* %125, null
  %127 = icmp ne %class.Packet* %2, null
  %128 = and i1 %127, %126
  br i1 %128, label %130, label %129

129:                                              ; preds = %121
  call void @__assert_fail(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.58.14334, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 767, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4Port4pushEP6Packet.14335, i64 0, i64 0)) #57
  unreachable

130:                                              ; preds = %121
  %131 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %123, i64 1, i32 1
  %132 = load i32, i32* %131, align 8, !tbaa !20280
  %133 = bitcast %class.Element* %125 to void (%class.Element*, i32, %class.Packet*)***
  %134 = load void (%class.Element*, i32, %class.Packet*)**, void (%class.Element*, i32, %class.Packet*)*** %133, align 8, !tbaa !20285
  %135 = getelementptr inbounds void (%class.Element*, i32, %class.Packet*)*, void (%class.Element*, i32, %class.Packet*)** %134, i64 2
  %136 = load void (%class.Element*, i32, %class.Packet*)*, void (%class.Element*, i32, %class.Packet*)** %135, align 8
  call void %136(%class.Element* nonnull %125, i32 %132, %class.Packet* nonnull %2)
  br label %143

137:                                              ; preds = %117
  call void @llvm.lifetime.start.p0i8(i64 1, i8* nonnull %7) #34
  %138 = getelementptr inbounds %class.Packet, %class.Packet* %2, i64 0, i32 0, i32 0
  call void asm sideeffect "lock ; decl $0 ; sete $1", "=*m,=*qm,*m,~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %138, i8* nonnull %7, i32* %138) #34, !srcloc !23498
  %139 = load i8, i8* %7, align 1, !tbaa !20287
  %140 = icmp eq i8 %139, 0
  call void @llvm.lifetime.end.p0i8(i64 1, i8* nonnull %7) #34
  br i1 %140, label %143, label %141

141:                                              ; preds = %137
  %142 = bitcast %class.Packet* %2 to %class.WritablePacket*
  call void @_ZN14WritablePacket7recycleEPS_(%class.WritablePacket* %142)
  br label %143

143:                                              ; preds = %141, %137, %130
  ret %class.Packet* null
}



