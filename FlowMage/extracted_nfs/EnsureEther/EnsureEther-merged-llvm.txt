/***  ensureether.cc ***/

/*
 * ensureether.{cc,hh} -- ensures that IP packets are Ethernet-encapsulated
 * Eddie Kohler
 *
 * Copyright (c) 2001 International Computer Science Institute
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, subject to the conditions
 * listed in the Click LICENSE file. These conditions include: you must
 * preserve this copyright notice, and you cannot mention the copyright
 * holders in advertising related to the Software without their permission.
 * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
 * notice is a summary of the Click LICENSE file; the license in that file is
 * legally binding.
 */

#include <click/config.h>
#include "ensureether.hh"
#include <click/etheraddress.hh>
#include <click/args.hh>
#include <click/error.hh>
#include <click/glue.hh>
CLICK_DECLS

EnsureEther::EnsureEther()
{
}

EnsureEther::~EnsureEther()
{
}

int
EnsureEther::configure(Vector<String> &conf, ErrorHandler *errh)
{
    unsigned etht = 0x0800;
    memset(&_ethh.ether_shost, 1, 6);
    memset(&_ethh.ether_dhost, 2, 6);
    if (Args(conf, this, errh)
        .read_p("ETHERTYPE", etht)
        .read_p("SRC", EtherAddressArg(), _ethh.ether_shost)
        .read_p("DST", EtherAddressArg(), _ethh.ether_dhost)
        .complete() < 0)
        return -1;

    if (etht > 0xFFFF)
        return errh->error("argument 1 (Ethernet encapsulation type) must be <= 0xFFFF");

    _ethh.ether_type = htons(etht);

    return 0;
}

Packet *
EnsureEther::smaction(Packet *p)
{
    if (!p->has_network_header() || p->ip_header_offset() < 0)
        return p;

    if (p->ip_header_offset() == 14) {
        // check for an existing Ethernet header
        const click_ether *ethh = (const click_ether *)p->data();
        if (ethh->ether_type == htons(ETHERTYPE_IP)
         || ethh->ether_type == htons(ETHERTYPE_IP6))
            return p;
    } else if (p->ip_header_offset() == 0 && p->headroom() >= 14) {
        // check for an Ethernet header that had been stripped
        const click_ether *ethh = (const click_ether *)(p->data() - 14);
        if (ethh->ether_type == htons(ETHERTYPE_IP)
         || ethh->ether_type == htons(ETHERTYPE_IP6))
            return p->nonunique_push(14);
    }

    // need to prepend our own Ethernet header
    p->pull(p->ip_header_offset());
    if (WritablePacket *q = p->push(14)) {
        memcpy(q->data(), &_ethh, 14);
        return q;
    } else
        return 0;
}

void
EnsureEther::push(int, Packet *p)
{
    if (Packet *q = smaction(p))
        output(0).push(q);
}

Packet *
EnsureEther::pull(int)
{
    if (Packet *p = input(0).pull())
        return smaction(p);
    else
        return 0;
}

#if HAVE_BATCH
void
EnsureEther::push_batch(int, PacketBatch *batch)
{
    EXECUTE_FOR_EACH_PACKET_DROPPABLE(smaction, batch, [](Packet *){});
    if (batch)
        output(0).push_batch(batch);
}

PacketBatch *
EnsureEther::pull_batch(int port, unsigned max)
{
    PacketBatch *batch;
    MAKE_BATCH(EnsureEther::pull(port), batch, max);
    return batch;
}

#endif

CLICK_ENDDECLS
EXPORT_ELEMENT(EnsureEther)


/***  EnsureEther_llvm.txt ***/

define dso_local void @_ZN11EnsureEtherC2Ev(%class.EnsureEther* %0) unnamed_addr #2 align 2 {
  %2 = getelementptr %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 0
  %3 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 1
  %4 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 2
  store i8 0, i8* %4, align 4, !tbaa !20277
  %5 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 0
  %6 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %5, i64 0, i32 0
  store %class.Element* null, %class.Element** %6, align 8, !tbaa !20278
  %7 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 0, i32 1
  store i32 -2, i32* %7, align 8, !tbaa !20280
  %8 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 1, i32 0
  store %class.Element* null, %class.Element** %8, align 8, !tbaa !20278
  %9 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 1, i32 1
  store i32 -2, i32* %9, align 8, !tbaa !20280
  %10 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 2, i32 0
  store %class.Element* null, %class.Element** %10, align 8, !tbaa !20278
  %11 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 2, i32 1
  store i32 -2, i32* %11, align 8, !tbaa !20280
  %12 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 3, i32 0
  store %class.Element* null, %class.Element** %12, align 8, !tbaa !20278
  %13 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 3, i32 1
  store i32 -2, i32* %13, align 8, !tbaa !20280
  %14 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 7
  store %class.Router* null, %class.Router** %14, align 8, !tbaa !20281
  %15 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 8
  store i32 -1, i32* %15, align 8, !tbaa !20282
  %16 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 10
  %17 = bitcast %class.Vector* %16 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(17) %17, i8 0, i64 17, i1 false) #34
  %18 = load i32, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %19 = add nsw i32 %18, 1
  store i32 %19, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %20 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 1
  store %"class.Element::Port"* %5, %"class.Element::Port"** %20, align 8, !tbaa !20284
  %21 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 0
  store %"class.Element::Port"* %5, %"class.Element::Port"** %21, align 8, !tbaa !20284
  %22 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6, i64 1
  store i32 0, i32* %22, align 4, !tbaa !20283
  %23 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6, i64 0
  store i32 0, i32* %23, align 8, !tbaa !20283
  store i32 1, i32* %3, align 8, !tbaa !20267
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [39 x i8*] }, { [39 x i8*] }* @_ZTV11EnsureEther, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8, !tbaa !20285
  ret void
}

define dso_local void @_ZN11EnsureEtherD2Ev(%class.EnsureEther* %0) unnamed_addr #2 align 2 personality i32 (...)* @__gxx_personality_v0 {
  %2 = getelementptr %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 0
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [38 x i8*] }, { [38 x i8*] }* @_ZTV7Element, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8, !tbaa !20285
  %3 = load i32, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %4 = add nsw i32 %3, -1
  store i32 %4, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %5 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 0
  %6 = load %"class.Element::Port"*, %"class.Element::Port"** %5, align 8, !tbaa !20284
  %7 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 0
  %8 = icmp uge %"class.Element::Port"* %6, %7
  %9 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6
  %10 = bitcast [2 x i32]* %9 to %"class.Element::Port"*
  %11 = icmp ule %"class.Element::Port"* %6, %10
  %12 = and i1 %11, %8
  %13 = icmp eq %"class.Element::Port"* %6, null
  %14 = or i1 %13, %12
  br i1 %14, label %17, label %15

15:                                               ; preds = %1
  %16 = bitcast %"class.Element::Port"* %6 to i8*
  tail call void @_ZdaPv(i8* %16) #55
  br label %17

17:                                               ; preds = %15, %1
  %18 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 1
  %19 = load %"class.Element::Port"*, %"class.Element::Port"** %18, align 8, !tbaa !20284
  %20 = icmp uge %"class.Element::Port"* %19, %7
  %21 = icmp ule %"class.Element::Port"* %19, %10
  %22 = and i1 %21, %20
  %23 = icmp eq %"class.Element::Port"* %19, null
  %24 = or i1 %23, %22
  br i1 %24, label %27, label %25

25:                                               ; preds = %17
  %26 = bitcast %"class.Element::Port"* %19 to i8*
  tail call void @_ZdaPv(i8* %26) #55
  br label %27

27:                                               ; preds = %25, %17
  %28 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 10
  %29 = bitcast %class.Vector* %28 to i8**
  %30 = load i8*, i8** %29, align 8, !tbaa !20288
  %31 = icmp eq i8* %30, null
  br i1 %31, label %_ZN12BatchElementD2Ev.exit, label %32

32:                                               ; preds = %27
  tail call void @_ZdaPv(i8* nonnull %30) #55
  br label %_ZN12BatchElementD2Ev.exit

_ZN12BatchElementD2Ev.exit:                       ; preds = %32, %27
  ret void
}

define dso_local void @_ZN11EnsureEtherD0Ev(%class.EnsureEther* %0) unnamed_addr #2 align 2 personality i32 (...)* @__gxx_personality_v0 {
  %2 = getelementptr %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 0
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [38 x i8*] }, { [38 x i8*] }* @_ZTV7Element, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8, !tbaa !20285
  %3 = load i32, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %4 = add nsw i32 %3, -1
  store i32 %4, i32* @_ZN7Element19nelements_allocatedE, align 4, !tbaa !20283
  %5 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 0
  %6 = load %"class.Element::Port"*, %"class.Element::Port"** %5, align 8, !tbaa !20284
  %7 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 5, i64 0
  %8 = icmp uge %"class.Element::Port"* %6, %7
  %9 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6
  %10 = bitcast [2 x i32]* %9 to %"class.Element::Port"*
  %11 = icmp ule %"class.Element::Port"* %6, %10
  %12 = and i1 %11, %8
  %13 = icmp eq %"class.Element::Port"* %6, null
  %14 = or i1 %13, %12
  br i1 %14, label %17, label %15

15:                                               ; preds = %1
  %16 = bitcast %"class.Element::Port"* %6 to i8*
  tail call void @_ZdaPv(i8* %16) #55
  br label %17

17:                                               ; preds = %15, %1
  %18 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 1
  %19 = load %"class.Element::Port"*, %"class.Element::Port"** %18, align 8, !tbaa !20284
  %20 = icmp uge %"class.Element::Port"* %19, %7
  %21 = icmp ule %"class.Element::Port"* %19, %10
  %22 = and i1 %21, %20
  %23 = icmp eq %"class.Element::Port"* %19, null
  %24 = or i1 %23, %22
  br i1 %24, label %27, label %25

25:                                               ; preds = %17
  %26 = bitcast %"class.Element::Port"* %19 to i8*
  tail call void @_ZdaPv(i8* %26) #55
  br label %27

27:                                               ; preds = %25, %17
  %28 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 10
  %29 = bitcast %class.Vector* %28 to i8**
  %30 = load i8*, i8** %29, align 8, !tbaa !20288
  %31 = icmp eq i8* %30, null
  br i1 %31, label %_ZN12BatchElementD2Ev.exit, label %32

32:                                               ; preds = %27
  tail call void @_ZdaPv(i8* nonnull %30) #55
  br label %_ZN12BatchElementD2Ev.exit

_ZN12BatchElementD2Ev.exit:                       ; preds = %32, %27
  ret void
}

define dso_local void @_ZN11EnsureEther4pushEiP6Packet(%class.EnsureEther* nocapture readonly %0, i32 %1, %class.Packet* %2) unnamed_addr #0 align 2 {
  %4 = tail call %class.Packet* @_ZN11EnsureEther8smactionEP6Packet(%class.EnsureEther* %0, %class.Packet* %2)
  %5 = icmp eq %class.Packet* %4, null
  br i1 %5, label %25, label %6

6:                                                ; preds = %3
  %7 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6, i64 1
  %8 = load i32, i32* %7, align 4, !tbaa !20283
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %11

10:                                               ; preds = %6
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

11:                                               ; preds = %6
  %12 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 1
  %13 = load %"class.Element::Port"*, %"class.Element::Port"** %12, align 8, !tbaa !20284
  %14 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %13, i64 0, i32 0
  %15 = load %class.Element*, %class.Element** %14, align 8, !tbaa !20278
  %16 = icmp eq %class.Element* %15, null
  br i1 %16, label %17, label %18

17:                                               ; preds = %11
  tail call void @__assert_fail(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.58.14334, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 767, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4Port4pushEP6Packet.14335, i64 0, i64 0)) #57
  unreachable

18:                                               ; preds = %11
  %19 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %13, i64 0, i32 1
  %20 = load i32, i32* %19, align 8, !tbaa !20280
  %21 = bitcast %class.Element* %15 to void (%class.Element*, i32, %class.Packet*)***
  %22 = load void (%class.Element*, i32, %class.Packet*)**, void (%class.Element*, i32, %class.Packet*)*** %21, align 8, !tbaa !20285
  %23 = getelementptr inbounds void (%class.Element*, i32, %class.Packet*)*, void (%class.Element*, i32, %class.Packet*)** %22, i64 2
  %24 = load void (%class.Element*, i32, %class.Packet*)*, void (%class.Element*, i32, %class.Packet*)** %23, align 8
  tail call void %24(%class.Element* nonnull %15, i32 %20, %class.Packet* nonnull %4)
  br label %25

25:                                               ; preds = %18, %3
  ret void
}

define dso_local %class.Packet* @_ZN11EnsureEther4pullEi(%class.EnsureEther* nocapture readonly %0, i32 %1) unnamed_addr #0 align 2 {
  %3 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6, i64 0
  %4 = load i32, i32* %3, align 4, !tbaa !20283
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %7

6:                                                ; preds = %2
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

7:                                                ; preds = %2
  %8 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 0
  %9 = load %"class.Element::Port"*, %"class.Element::Port"** %8, align 8, !tbaa !20284
  %10 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %9, i64 0, i32 0
  %11 = load %class.Element*, %class.Element** %10, align 8, !tbaa !20278
  %12 = icmp eq %class.Element* %11, null
  br i1 %12, label %13, label %14

13:                                               ; preds = %7
  tail call void @__assert_fail(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.59.14332, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 843, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4Port4pullEv.14333, i64 0, i64 0)) #57
  unreachable

14:                                               ; preds = %7
  %15 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %9, i64 0, i32 1
  %16 = load i32, i32* %15, align 8, !tbaa !20280
  %17 = bitcast %class.Element* %11 to %class.Packet* (%class.Element*, i32)***
  %18 = load %class.Packet* (%class.Element*, i32)**, %class.Packet* (%class.Element*, i32)*** %17, align 8, !tbaa !20285
  %19 = getelementptr inbounds %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %18, i64 3
  %20 = load %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %19, align 8
  %21 = tail call %class.Packet* %20(%class.Element* nonnull %11, i32 %16)
  %22 = icmp eq %class.Packet* %21, null
  br i1 %22, label %25, label %23

23:                                               ; preds = %14
  %24 = tail call %class.Packet* @_ZN11EnsureEther8smactionEP6Packet(%class.EnsureEther* nonnull %0, %class.Packet* nonnull %21)
  br label %25

25:                                               ; preds = %23, %14
  %26 = phi %class.Packet* [ %24, %23 ], [ null, %14 ]
  ret %class.Packet* %26
}

define dso_local void @_ZN11EnsureEther10push_batchEiP11PacketBatch(%class.EnsureEther* nocapture readonly %0, i32 %1, %class.PacketBatch* %2) unnamed_addr #0 align 2 {
  %4 = icmp eq %class.PacketBatch* %2, null
  br i1 %4, label %5, label %9

5:                                                ; preds = %3
  %6 = load i16, i16* inttoptr (i64 72 to i16*), align 8, !tbaa !20287
  %7 = icmp eq i16 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %5
  tail call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.259.16395, i64 0, i64 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6.13925, i64 0, i64 0), i32 439, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__PRETTY_FUNCTION__._ZN11PacketBatch5countEv.13926, i64 0, i64 0)) #57
  unreachable

9:                                                ; preds = %3
  %10 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %2, i64 48, i32 0
  %11 = getelementptr inbounds i8, i8* %10, i64 24
  %12 = bitcast i8* %11 to i16*
  %13 = load i16, i16* %12, align 2, !tbaa !20287
  %14 = icmp eq i16 %13, 0
  br i1 %14, label %15, label %16

15:                                               ; preds = %9
  tail call void @__assert_fail(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.259.16395, i64 0, i64 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6.13925, i64 0, i64 0), i32 439, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__PRETTY_FUNCTION__._ZN11PacketBatch5countEv.13926, i64 0, i64 0)) #57
  unreachable

16:                                               ; preds = %9
  %17 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %2, i64 136
  %18 = bitcast %class.PacketBatch* %17 to %class.Packet**
  %19 = bitcast %class.PacketBatch* %2 to %class.Packet*
  %20 = zext i16 %13 to i32
  br label %21

21:                                               ; preds = %50, %16
  %22 = phi %class.PacketBatch* [ %53, %50 ], [ %2, %16 ]
  %23 = phi i32 [ %52, %50 ], [ %20, %16 ]
  %24 = phi %class.Packet* [ %51, %50 ], [ null, %16 ]
  %25 = phi %class.Packet* [ %27, %50 ], [ %19, %16 ]
  %26 = phi %class.Packet** [ %55, %50 ], [ %18, %16 ]
  %27 = load %class.Packet*, %class.Packet** %26, align 8, !tbaa !20284
  %28 = tail call %class.Packet* @_ZN11EnsureEther8smactionEP6Packet(%class.EnsureEther* %0, %class.Packet* nonnull %25)
  %29 = icmp eq %class.Packet* %28, null
  br i1 %29, label %30, label %39

30:                                               ; preds = %21
  %31 = icmp eq %class.Packet* %24, null
  br i1 %31, label %34, label %32

32:                                               ; preds = %30
  %33 = getelementptr inbounds %class.Packet, %class.Packet* %24, i64 0, i32 6, i32 6
  store %class.Packet* %27, %class.Packet** %33, align 8, !tbaa !20337
  br label %36

34:                                               ; preds = %30
  %35 = bitcast %class.Packet* %27 to %class.PacketBatch*
  br label %36

36:                                               ; preds = %34, %32
  %37 = phi %class.PacketBatch* [ %22, %32 ], [ %35, %34 ]
  %38 = add nsw i32 %23, -1
  br label %50

39:                                               ; preds = %21
  %40 = icmp eq %class.Packet* %28, %25
  br i1 %40, label %50, label %41

41:                                               ; preds = %39
  %42 = icmp eq %class.Packet* %24, null
  br i1 %42, label %45, label %43

43:                                               ; preds = %41
  %44 = getelementptr inbounds %class.Packet, %class.Packet* %24, i64 0, i32 6, i32 6
  store %class.Packet* %28, %class.Packet** %44, align 8, !tbaa !20337
  br label %47

45:                                               ; preds = %41
  %46 = bitcast %class.Packet* %28 to %class.PacketBatch*
  br label %47

47:                                               ; preds = %45, %43
  %48 = phi %class.PacketBatch* [ %22, %43 ], [ %46, %45 ]
  %49 = getelementptr inbounds %class.Packet, %class.Packet* %28, i64 0, i32 6, i32 6
  store %class.Packet* %27, %class.Packet** %49, align 8, !tbaa !20337
  br label %50

50:                                               ; preds = %47, %39, %36
  %51 = phi %class.Packet* [ %24, %36 ], [ %25, %39 ], [ %28, %47 ]
  %52 = phi i32 [ %38, %36 ], [ %23, %39 ], [ %23, %47 ]
  %53 = phi %class.PacketBatch* [ %37, %36 ], [ %22, %39 ], [ %48, %47 ]
  %54 = icmp eq %class.Packet* %27, null
  %55 = getelementptr inbounds %class.Packet, %class.Packet* %27, i64 0, i32 6, i32 6
  br i1 %54, label %56, label %21

56:                                               ; preds = %50
  %57 = icmp eq %class.PacketBatch* %53, null
  br i1 %57, label %81, label %58

58:                                               ; preds = %56
  %59 = trunc i32 %52 to i16
  %60 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %53, i64 48, i32 0
  %61 = getelementptr inbounds i8, i8* %60, i64 24
  %62 = bitcast i8* %61 to i16*
  store i16 %59, i16* %62, align 2, !tbaa !20287
  %63 = getelementptr inbounds %class.PacketBatch, %class.PacketBatch* %53, i64 144
  %64 = bitcast %class.PacketBatch* %63 to %class.Packet**
  store %class.Packet* %51, %class.Packet** %64, align 8, !tbaa !20334
  %65 = getelementptr inbounds %class.Packet, %class.Packet* %51, i64 0, i32 6, i32 6
  store %class.Packet* null, %class.Packet** %65, align 8, !tbaa !20337
  %66 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6, i64 1
  %67 = load i32, i32* %66, align 4, !tbaa !20283
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %69, label %70

69:                                               ; preds = %58
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

70:                                               ; preds = %58
  %71 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 1
  %72 = load %"class.Element::Port"*, %"class.Element::Port"** %71, align 8, !tbaa !20284
  %73 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %72, i64 0, i32 0
  %74 = load %class.Element*, %class.Element** %73, align 8, !tbaa !20278
  %75 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %72, i64 0, i32 1
  %76 = load i32, i32* %75, align 8, !tbaa !20280
  %77 = bitcast %class.Element* %74 to void (%class.Element*, i32, %class.PacketBatch*)***
  %78 = load void (%class.Element*, i32, %class.PacketBatch*)**, void (%class.Element*, i32, %class.PacketBatch*)*** %77, align 8, !tbaa !20285
  %79 = getelementptr inbounds void (%class.Element*, i32, %class.PacketBatch*)*, void (%class.Element*, i32, %class.PacketBatch*)** %78, i64 5
  %80 = load void (%class.Element*, i32, %class.PacketBatch*)*, void (%class.Element*, i32, %class.PacketBatch*)** %79, align 8
  tail call void %80(%class.Element* %74, i32 %76, %class.PacketBatch* nonnull %53)
  br label %81

81:                                               ; preds = %70, %56, %5
  ret void
}

define dso_local %class.PacketBatch* @_ZN11EnsureEther10pull_batchEij(%class.EnsureEther* nocapture readonly %0, i32 %1, i32 %2) unnamed_addr #0 align 2 {
  %4 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 6, i64 0
  %5 = load i32, i32* %4, align 4, !tbaa !20283
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %7, label %8

7:                                                ; preds = %3
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

8:                                                ; preds = %3
  %9 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 0, i32 0, i32 4, i64 0
  %10 = load %"class.Element::Port"*, %"class.Element::Port"** %9, align 8, !tbaa !20284
  %11 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %10, i64 0, i32 0
  %12 = load %class.Element*, %class.Element** %11, align 8, !tbaa !20278
  %13 = icmp eq %class.Element* %12, null
  br i1 %13, label %14, label %15

14:                                               ; preds = %8
  tail call void @__assert_fail(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.59.14332, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 843, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4Port4pullEv.14333, i64 0, i64 0)) #57
  unreachable

15:                                               ; preds = %8
  %16 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %10, i64 0, i32 1
  %17 = load i32, i32* %16, align 8, !tbaa !20280
  %18 = bitcast %class.Element* %12 to %class.Packet* (%class.Element*, i32)***
  %19 = load %class.Packet* (%class.Element*, i32)**, %class.Packet* (%class.Element*, i32)*** %18, align 8, !tbaa !20285
  %20 = getelementptr inbounds %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %19, i64 3
  %21 = load %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %20, align 8
  %22 = tail call %class.Packet* %21(%class.Element* nonnull %12, i32 %17)
  %23 = icmp eq %class.Packet* %22, null
  br i1 %23, label %66, label %24

24:                                               ; preds = %15
  %25 = tail call %class.Packet* @_ZN11EnsureEther8smactionEP6Packet(%class.EnsureEther* nonnull %0, %class.Packet* nonnull %22)
  %26 = bitcast %class.Packet* %25 to %class.PacketBatch*
  %27 = icmp eq %class.Packet* %25, null
  br i1 %27, label %66, label %28

28:                                               ; preds = %24
  %29 = icmp eq i32 %2, 0
  %30 = select i1 %29, i32 256, i32 %2
  %31 = icmp ugt i32 %30, 1
  br i1 %31, label %.preheader, label %.loopexit

.preheader:                                       ; preds = %55, %28
  %32 = phi %class.Packet* [ %53, %55 ], [ %25, %28 ]
  %33 = phi i32 [ %57, %55 ], [ 1, %28 ]
  %34 = load i32, i32* %4, align 4, !tbaa !20283
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %36, label %37

36:                                               ; preds = %.preheader
  tail call void @__assert_fail(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.56.14329, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 568, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4portEbi.14331, i64 0, i64 0)) #57
  unreachable

37:                                               ; preds = %.preheader
  %38 = load %"class.Element::Port"*, %"class.Element::Port"** %9, align 8, !tbaa !20284
  %39 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %38, i64 0, i32 0
  %40 = load %class.Element*, %class.Element** %39, align 8, !tbaa !20278
  %41 = icmp eq %class.Element* %40, null
  br i1 %41, label %42, label %43

42:                                               ; preds = %37
  tail call void @__assert_fail(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.59.14332, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.96.15137, i64 0, i64 0), i32 843, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @__PRETTY_FUNCTION__._ZNK7Element4Port4pullEv.14333, i64 0, i64 0)) #57
  unreachable

43:                                               ; preds = %37
  %44 = getelementptr inbounds %"class.Element::Port", %"class.Element::Port"* %38, i64 0, i32 1
  %45 = load i32, i32* %44, align 8, !tbaa !20280
  %46 = bitcast %class.Element* %40 to %class.Packet* (%class.Element*, i32)***
  %47 = load %class.Packet* (%class.Element*, i32)**, %class.Packet* (%class.Element*, i32)*** %46, align 8, !tbaa !20285
  %48 = getelementptr inbounds %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %47, i64 3
  %49 = load %class.Packet* (%class.Element*, i32)*, %class.Packet* (%class.Element*, i32)** %48, align 8
  %50 = tail call %class.Packet* %49(%class.Element* nonnull %40, i32 %45)
  %51 = icmp eq %class.Packet* %50, null
  br i1 %51, label %.loopexit, label %52

52:                                               ; preds = %43
  %53 = tail call %class.Packet* @_ZN11EnsureEther8smactionEP6Packet(%class.EnsureEther* nonnull %0, %class.Packet* nonnull %50)
  %54 = icmp eq %class.Packet* %53, null
  br i1 %54, label %.loopexit, label %55

55:                                               ; preds = %52
  %56 = getelementptr inbounds %class.Packet, %class.Packet* %32, i64 0, i32 6, i32 6
  store %class.Packet* %53, %class.Packet** %56, align 8, !tbaa !20337
  %57 = add nuw i32 %33, 1
  %58 = icmp eq i32 %57, %30
  br i1 %58, label %.loopexit, label %.preheader

.loopexit:                                        ; preds = %55, %52, %43, %28
  %59 = phi i32 [ 1, %28 ], [ %30, %55 ], [ %33, %52 ], [ %33, %43 ]
  %60 = phi %class.Packet* [ %25, %28 ], [ %53, %55 ], [ %32, %52 ], [ %32, %43 ]
  %61 = trunc i32 %59 to i16
  %62 = getelementptr inbounds %class.Packet, %class.Packet* %25, i64 0, i32 6, i32 0, i32 0, i64 3
  %63 = bitcast i64* %62 to i16*
  store i16 %61, i16* %63, align 2, !tbaa !20287
  %64 = getelementptr inbounds %class.Packet, %class.Packet* %25, i64 0, i32 6, i32 7
  store %class.Packet* %60, %class.Packet** %64, align 8, !tbaa !20334
  %65 = getelementptr inbounds %class.Packet, %class.Packet* %60, i64 0, i32 6, i32 6
  store %class.Packet* null, %class.Packet** %65, align 8, !tbaa !20337
  br label %66

66:                                               ; preds = %.loopexit, %24, %15
  %67 = phi %class.PacketBatch* [ %26, %.loopexit ], [ %26, %24 ], [ null, %15 ]
  ret %class.PacketBatch* %67
}

define internal i8* @_ZNK11EnsureEther10class_nameEv(%class.EnsureEther* nocapture readnone %0) unnamed_addr #4 comdat align 2 {
  ret i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.62.13066, i64 0, i64 0)
}

define internal i8* @_ZNK11EnsureEther10port_countEv(%class.EnsureEther* nocapture readnone %0) unnamed_addr #4 comdat align 2 {
  ret i8* getelementptr inbounds ([2 x i8], [2 x i8]* @_ZN7Element9PORTS_1_1E, i64 0, i64 0)
}

define dso_local i32 @_ZN11EnsureEther9configureER6VectorI6StringLm16EEP12ErrorHandler(%class.EnsureEther* %0, %class.Vector.0* dereferenceable(16) %1, %class.ErrorHandler* %2) unnamed_addr #0 align 2 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  %4 = alloca i32, align 4
  %5 = alloca %class.Args, align 8
  %6 = bitcast i32* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %6) #34
  store i32 2048, i32* %4, align 4, !tbaa !20283
  %7 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 1
  %8 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 1, i32 1
  %9 = getelementptr [6 x i8], [6 x i8]* %8, i64 0, i64 0
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 1 dereferenceable(6) %9, i8 1, i64 6, i1 false)
  %10 = getelementptr inbounds %struct.click_ether, %struct.click_ether* %7, i64 0, i32 0
  %11 = getelementptr inbounds %struct.click_ether, %struct.click_ether* %7, i64 0, i32 0, i64 0
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 1 dereferenceable(6) %11, i8 2, i64 6, i1 false)
  %12 = bitcast %class.Args* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 112, i8* nonnull %12) #34
  %13 = bitcast %class.Args* %5 to %class.EnsureEther**
  store %class.EnsureEther* %0, %class.EnsureEther** %13, align 8, !tbaa !20294
  %14 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 0, i32 1
  store %class.ErrorHandler* %2, %class.ErrorHandler** %14, align 8, !tbaa !20296
  %15 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 0, i32 2
  store i8* null, i8** %15, align 8, !tbaa !20297
  %16 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 0, i32 3
  store i8 0, i8* %16, align 8, !tbaa !20298
  %17 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 5
  %18 = bitcast %class.Vector.2* %17 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(16) %18, i8 0, i64 16, i1 false) #34
  invoke void @_ZN4Args10initializeEPK6VectorI6StringLm16EE(%class.Args* nonnull %5, %class.Vector.0* nonnull %1)
          to label %_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit unwind label %19

19:                                               ; preds = %3
  %20 = landingpad { i8*, i32 }
          cleanup
  %21 = bitcast %class.Vector.2* %17 to i8**
  %22 = load i8*, i8** %21, align 8, !tbaa !20299
  %23 = icmp eq i8* %22, null
  br i1 %23, label %25, label %24

24:                                               ; preds = %19
  call void @_ZdaPv(i8* nonnull %22) #55
  br label %25

25:                                               ; preds = %24, %19
  resume { i8*, i32 } %20

_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit: ; preds = %3
  invoke void @_Z14args_base_readIjEvP4ArgsPKciRT_(%class.Args* nonnull %5, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.4.2576, i64 0, i64 0), i32 2, i32* nonnull dereferenceable(4) %4)
          to label %26 unwind label %.loopexit.split-lp

26:                                               ; preds = %_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit
  invoke fastcc void @_Z14args_base_readI15EtherAddressArgA6_hEvP4ArgsPKciT_RT0_(%class.Args* nonnull %5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8714, i64 0, i64 0), i32 2, [6 x i8]* nonnull dereferenceable(6) %8)
          to label %27 unwind label %.loopexit.split-lp

27:                                               ; preds = %26
  invoke fastcc void @_Z14args_base_readI15EtherAddressArgA6_hEvP4ArgsPKciT_RT0_(%class.Args* nonnull %5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1.12088, i64 0, i64 0), i32 2, [6 x i8]* nonnull dereferenceable(6) %10)
          to label %28 unwind label %.loopexit.split-lp

28:                                               ; preds = %27
  invoke void @_ZN4Args14check_completeEv(%class.Args* nonnull %5)
          to label %.noexc unwind label %.loopexit.split-lp

.noexc:                                           ; preds = %28
  %29 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 2
  %30 = load i8, i8* %29, align 2, !tbaa !20301, !range !20292
  %31 = icmp eq i8 %30, 0
  br i1 %31, label %_ZN4Args8completeEv.exit, label %32

32:                                               ; preds = %.noexc
  %33 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 6
  %34 = load %"struct.Args::Slot"*, %"struct.Args::Slot"** %33, align 8, !tbaa !20304
  %35 = icmp eq %"struct.Args::Slot"* %34, null
  br i1 %35, label %.loopexit3, label %36

36:                                               ; preds = %32
  %37 = bitcast %"struct.Args::Slot"** %33 to i64*
  br label %41

.loopexit3:                                       ; preds = %.noexc1, %32
  %38 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 3
  %39 = load i8, i8* %38, align 1, !tbaa !20305
  %40 = icmp eq i8 %39, 0
  br i1 %40, label %.loopexit, label %.preheader

41:                                               ; preds = %.noexc1, %36
  %42 = phi %"struct.Args::Slot"* [ %34, %36 ], [ %53, %.noexc1 ]
  %43 = getelementptr inbounds %"struct.Args::Slot", %"struct.Args::Slot"* %42, i64 0, i32 1
  %44 = bitcast %"struct.Args::Slot"** %43 to i64*
  %45 = load i64, i64* %44, align 8, !tbaa !20306
  store i64 %45, i64* %37, align 8, !tbaa !20304
  %46 = bitcast %"struct.Args::Slot"* %42 to void (%"struct.Args::Slot"*)***
  %47 = load void (%"struct.Args::Slot"*)**, void (%"struct.Args::Slot"*)*** %46, align 8, !tbaa !20285
  %48 = getelementptr inbounds void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %47, i64 2
  %49 = load void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %48, align 8
  invoke void %49(%"struct.Args::Slot"* nonnull %42)
          to label %.noexc1 unwind label %.loopexit2

.noexc1:                                          ; preds = %41
  %50 = load void (%"struct.Args::Slot"*)**, void (%"struct.Args::Slot"*)*** %46, align 8, !tbaa !20285
  %51 = getelementptr inbounds void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %50, i64 1
  %52 = load void (%"struct.Args::Slot"*)*, void (%"struct.Args::Slot"*)** %51, align 8
  call void %52(%"struct.Args::Slot"* nonnull %42) #34
  %53 = load %"struct.Args::Slot"*, %"struct.Args::Slot"** %33, align 8, !tbaa !20304
  %54 = icmp eq %"struct.Args::Slot"* %53, null
  br i1 %54, label %.loopexit3, label %41

.loopexit:                                        ; preds = %.preheader, %.loopexit3
  %55 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 7, i64 0
  store i8 0, i8* %55, align 8, !tbaa !20287
  store i8 0, i8* %38, align 1, !tbaa !20305
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %5) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %12) #34
  %56 = load i32, i32* %4, align 4, !tbaa !20283
  %57 = icmp ugt i32 %56, 65535
  br i1 %57, label %80, label %82

.preheader:                                       ; preds = %.preheader, %.loopexit3
  %58 = phi i32 [ %75, %.preheader ], [ 0, %.loopexit3 ]
  %59 = zext i32 %58 to i64
  %60 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 7, i64 %59
  %61 = load i8, i8* %60, align 1, !tbaa !20287
  %62 = zext i8 %61 to i32
  %63 = add nuw nsw i32 %58, 1
  %64 = zext i32 %63 to i64
  %65 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 7, i64 %64
  %66 = add nuw nsw i32 %63, %62
  %67 = zext i32 %66 to i64
  %68 = getelementptr inbounds %class.Args, %class.Args* %5, i64 0, i32 7, i64 %67
  %69 = bitcast i8* %68 to i8**
  %70 = load i8*, i8** %69, align 8, !tbaa !20284
  %71 = zext i8 %61 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %70, i8* nonnull align 1 %65, i64 %71, i1 false)
  %72 = load i8, i8* %60, align 1, !tbaa !20287
  %73 = zext i8 %72 to i32
  %74 = add i32 %58, 9
  %75 = add i32 %74, %73
  %76 = load i8, i8* %38, align 1, !tbaa !20305
  %77 = zext i8 %76 to i32
  %78 = icmp ult i32 %75, %77
  br i1 %78, label %.preheader, label %.loopexit

_ZN4Args8completeEv.exit:                         ; preds = %.noexc
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %5) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %12) #34
  br label %86

.loopexit2:                                       ; preds = %41
  %lpad.loopexit = landingpad { i8*, i32 }
          cleanup
  br label %79

.loopexit.split-lp:                               ; preds = %28, %27, %26, %_ZN4ArgsC2ERK6VectorI6StringLm16EEPK7ElementP12ErrorHandler.exit
  %lpad.loopexit.split-lp = landingpad { i8*, i32 }
          cleanup
  br label %79

79:                                               ; preds = %.loopexit.split-lp, %.loopexit2
  %lpad.phi = phi { i8*, i32 } [ %lpad.loopexit, %.loopexit2 ], [ %lpad.loopexit.split-lp, %.loopexit.split-lp ]
  call void @_ZN4ArgsD2Ev(%class.Args* nonnull %5) #34
  call void @llvm.lifetime.end.p0i8(i64 112, i8* nonnull %12) #34
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %6) #34
  resume { i8*, i32 } %lpad.phi

80:                                               ; preds = %.loopexit
  %81 = call i32 (%class.ErrorHandler*, i8*, ...) @_ZN12ErrorHandler5errorEPKcz(%class.ErrorHandler* %2, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.3.2222, i64 0, i64 0))
  br label %86

82:                                               ; preds = %.loopexit
  %83 = trunc i32 %56 to i16
  %84 = call i16 @llvm.bswap.i16(i16 %83) #34
  %85 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 1, i32 2
  store i16 %84, i16* %85, align 1, !tbaa !22188
  br label %86

86:                                               ; preds = %82, %80, %_ZN4Args8completeEv.exit
  %87 = phi i32 [ %81, %80 ], [ 0, %82 ], [ -1, %_ZN4Args8completeEv.exit ]
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %6) #34
  ret i32 %87
}

define dso_local %class.Packet* @_ZN11EnsureEther8smactionEP6Packet(%class.EnsureEther* nocapture readonly %0, %class.Packet* %1) local_unnamed_addr #0 align 2 {
  %3 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 6, i32 2
  %4 = load i8*, i8** %3, align 8, !tbaa !20400
  %5 = icmp eq i8* %4, null
  br i1 %5, label %_ZN6Packet14expensive_pushEj.exit.thread, label %6

6:                                                ; preds = %2
  %7 = ptrtoint i8* %4 to i64
  %8 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 3
  %9 = bitcast i8** %8 to i64*
  %10 = load i64, i64* %9, align 8, !tbaa !20399
  %11 = sub i64 %7, %10
  %12 = trunc i64 %11 to i32
  %13 = icmp slt i32 %12, 0
  %14 = inttoptr i64 %10 to i8*
  br i1 %13, label %_ZN6Packet14expensive_pushEj.exit.thread, label %15

15:                                               ; preds = %6
  switch i32 %12, label %33 [
    i32 14, label %16
    i32 0, label %20
  ]

16:                                               ; preds = %15
  %17 = getelementptr inbounds i8, i8* %14, i64 12
  %18 = bitcast i8* %17 to i16*
  %19 = load i16, i16* %18, align 1, !tbaa !21414
  switch i16 %19, label %33 [
    i16 8, label %_ZN6Packet14expensive_pushEj.exit.thread
    i16 -8826, label %_ZN6Packet14expensive_pushEj.exit.thread
  ]

20:                                               ; preds = %15
  %21 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 2
  %22 = bitcast i8** %21 to i64*
  %23 = load i64, i64* %22, align 8, !tbaa !21043
  %24 = sub i64 %10, %23
  %25 = trunc i64 %24 to i32
  %26 = icmp ugt i32 %25, 13
  br i1 %26, label %27, label %33

27:                                               ; preds = %20
  %28 = getelementptr inbounds i8, i8* %14, i64 -2
  %29 = bitcast i8* %28 to i16*
  %30 = load i16, i16* %29, align 1, !tbaa !21414
  switch i16 %30, label %33 [
    i16 8, label %31
    i16 -8826, label %31
  ]

31:                                               ; preds = %27, %27
  %32 = getelementptr inbounds i8, i8* %14, i64 -14
  store i8* %32, i8** %8, align 8, !tbaa !20399
  br label %_ZN6Packet14expensive_pushEj.exit.thread

33:                                               ; preds = %27, %20, %16, %15
  %34 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 4
  %35 = bitcast i8** %34 to i64*
  %36 = load i64, i64* %35, align 8, !tbaa !20396
  %37 = sub i64 %36, %10
  %38 = trunc i64 %37 to i32
  %39 = icmp ult i32 %38, %12
  br i1 %39, label %40, label %45

40:                                               ; preds = %33
  tail call void (i8*, ...) @click_chatter(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.63.12755, i64 0, i64 0), i32 %12, i32 %38)
  %41 = load i64, i64* %35, align 8, !tbaa !20396
  %42 = load i64, i64* %9, align 8, !tbaa !20399
  %43 = sub i64 %41, %42
  %44 = inttoptr i64 %42 to i8*
  br label %45

45:                                               ; preds = %40, %33
  %46 = phi i64 [ %36, %33 ], [ %41, %40 ]
  %47 = phi i8* [ %14, %33 ], [ %44, %40 ]
  %48 = phi i64 [ %11, %33 ], [ %43, %40 ]
  %49 = and i64 %48, 4294967295
  %50 = getelementptr inbounds i8, i8* %47, i64 %49
  store i8* %50, i8** %8, align 8, !tbaa !20399
  %51 = ptrtoint i8* %50 to i64
  %52 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 2
  %53 = bitcast i8** %52 to i64*
  %54 = load i64, i64* %53, align 8, !tbaa !21043
  %55 = sub i64 %51, %54
  %56 = trunc i64 %55 to i32
  %57 = icmp ult i32 %56, 14
  br i1 %57, label %66, label %58

58:                                               ; preds = %45
  %59 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 1
  %60 = load %class.Packet*, %class.Packet** %59, align 8, !tbaa !20801
  %61 = icmp eq %class.Packet* %60, null
  br i1 %61, label %62, label %.thread

62:                                               ; preds = %58
  %63 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 0, i32 0
  %64 = load volatile i32, i32* %63, align 4, !tbaa !20799
  %65 = icmp ugt i32 %64, 1
  br i1 %65, label %.thread, label %_ZN6Packet14expensive_pushEj.exit._crit_edge

66:                                               ; preds = %45
  %67 = load i32, i32* @_ZZN6Packet14expensive_pushEjE7chatter, align 4
  %68 = icmp slt i32 %67, 5
  %69 = and i1 %68, %57
  br i1 %69, label %70, label %.thread

70:                                               ; preds = %66
  tail call void (i8*, ...) @click_chatter(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.2.13909, i64 0, i64 0), i32 %56, i32 14)
  %71 = load i32, i32* @_ZZN6Packet14expensive_pushEjE7chatter, align 4, !tbaa !20283
  %72 = add nsw i32 %71, 1
  store i32 %72, i32* @_ZZN6Packet14expensive_pushEjE7chatter, align 4, !tbaa !20283
  %.pre = load i64, i64* %35, align 8, !tbaa !20396
  br label %.thread

.thread:                                          ; preds = %70, %66, %62, %58
  %73 = phi i64 [ %.pre, %70 ], [ %46, %66 ], [ %46, %62 ], [ %46, %58 ]
  %74 = getelementptr inbounds %class.Packet, %class.Packet* %1, i64 0, i32 5
  %75 = bitcast i8** %74 to i64*
  %76 = load i64, i64* %75, align 8, !tbaa !21044
  %77 = sub i64 %76, %73
  %78 = trunc i64 %77 to i32
  %79 = icmp slt i32 %78, 140
  %80 = select i1 %79, i32 0, i32 -140
  %81 = tail call %class.WritablePacket* @_ZN6Packet19expensive_uniqueifyEiib(%class.Packet* nonnull %1, i32 140, i32 %80, i1 zeroext true)
  %82 = icmp eq %class.WritablePacket* %81, null
  br i1 %82, label %_ZN6Packet14expensive_pushEj.exit.thread, label %_ZN6Packet14expensive_pushEj.exit.thread4

_ZN6Packet14expensive_pushEj.exit.thread4:        ; preds = %.thread
  %83 = getelementptr inbounds %class.WritablePacket, %class.WritablePacket* %81, i64 0, i32 0, i32 3
  %84 = load i8*, i8** %83, align 8, !tbaa !20399
  %85 = getelementptr inbounds i8, i8* %84, i64 -14
  store i8* %85, i8** %83, align 8, !tbaa !20399
  br label %88

_ZN6Packet14expensive_pushEj.exit._crit_edge:     ; preds = %62
  %86 = getelementptr inbounds i8, i8* %50, i64 -14
  store i8* %86, i8** %8, align 8, !tbaa !20399
  %87 = bitcast %class.Packet* %1 to %class.WritablePacket*
  br label %88

88:                                               ; preds = %_ZN6Packet14expensive_pushEj.exit._crit_edge, %_ZN6Packet14expensive_pushEj.exit.thread4
  %89 = phi i8* [ %85, %_ZN6Packet14expensive_pushEj.exit.thread4 ], [ %86, %_ZN6Packet14expensive_pushEj.exit._crit_edge ]
  %90 = phi %class.WritablePacket* [ %81, %_ZN6Packet14expensive_pushEj.exit.thread4 ], [ %87, %_ZN6Packet14expensive_pushEj.exit._crit_edge ]
  %91 = getelementptr inbounds %class.EnsureEther, %class.EnsureEther* %0, i64 0, i32 1, i32 0, i64 0
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 dereferenceable(14) %89, i8* nonnull align 1 dereferenceable(14) %91, i64 14, i1 false)
  %92 = getelementptr %class.WritablePacket, %class.WritablePacket* %90, i64 0, i32 0
  br label %_ZN6Packet14expensive_pushEj.exit.thread

_ZN6Packet14expensive_pushEj.exit.thread:         ; preds = %88, %.thread, %31, %16, %16, %6, %2
  %93 = phi %class.Packet* [ %1, %31 ], [ %1, %6 ], [ %1, %2 ], [ %1, %16 ], [ %92, %88 ], [ %1, %16 ], [ null, %.thread ]
  ret %class.Packet* %93
}



/***  ensureether.hh ***/

#ifndef CLICK_ENSUREETHER_HH
#define CLICK_ENSUREETHER_HH
#include <click/batchelement.hh>
#include <clicknet/ether.h>
CLICK_DECLS

/*
=c

EnsureEther([ETHERTYPE, SRC, DST])

=s ethernet

ensures that IP packets are Ethernet encapsulated

=d

Ensures that IP packets are encapsulated in an Ethernet header. Non-IP
packets, and IP packets that look Ethernet-encapsulated, are emitted on the
first output unchanged. Other IP packets are encapsulated in an Ethernet
header before being emitted. If the IP packet looks like it had an Ethernet
header that was stripped off, then that header is used. Otherwise, the header
specified by the arguments is prepended to the packet.

=e

Encapsulate packets without an Ethernet header with type
ETHERTYPE_IP (0x0800), source address 1:1:1:1:1:1, and
destination address 2:2:2:2:2:2:

  EnsureEther(0x0800, 1:1:1:1:1:1, 2:2:2:2:2:2)

=a

EtherEncap, EtherRewrite */

class EnsureEther : public BatchElement { public:

    EnsureEther() CLICK_COLD;
    ~EnsureEther() CLICK_COLD;

    const char *class_name() const override    { return "EnsureEther"; }
    const char *port_count() const override    { return PORTS_1_1; }

    int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;

    Packet *smaction(Packet *);
    void push(int, Packet *);
    Packet *pull(int);
#if HAVE_BATCH
    void push_batch(int, PacketBatch*) override;
    PacketBatch *pull_batch(int,unsigned) override;
#endif

  private:

    click_ether _ethh;

};

CLICK_ENDDECLS
#endif


